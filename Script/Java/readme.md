1. 스레드에 대해 자세히 설명해봐라
<details>
<summary>접기/펼치기</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
스레드는 자바 프로그램에서 동시에 실행되는 작업의 단위입니다. 스레드를 사용하면 한 번에 여러 작업을 처리하고 동시에 다른 작업을 수행할 수 있습니다. 스레드를 사용하면 여러 작업을 동시에 처리하여 프로그램의 성능을 향상시킬 수 있습니다.

자바에서 스레드를 사용하려면 java.lang.Thread 클래스를 사용합니다. 스레드를 생성하고 실행하기 위해 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현해야 합니다. Runnable 인터페이스를 구현하는 경우 Thread 클래스의 인스턴스를 생성하여 Runnable 객체를 매개변수로 전달하여 스레드를 실행시킬 수 있습니다.

스레드는 독립적인 실행 경로를 갖고 있으며, 각각의 스레드는 자체적인 스택 메모리를 가지고 있습니다. 스레드는 운영체제에서 관리되는데, 운영체제는 각 스레드에게 CPU 시간을 할당하여 번갈아 가면서 실행시킵니다. 이렇게 번갈아가면서 실행되는 과정을 스레드 스케줄링이라고 합니다.

스레드는 동시에 실행되는 작업의 단위이므로 서로 다른 스레드들은 동시에 실행될 수 있습니다. 이때 각 스레드는 공유되는 자원에 대한 접근을 조심해야 합니다. 동시에 여러 스레드가 공유 자원에 접근하면 예상치 못한 결과가 발생할 수 있으므로 적절한 동기화 메커니즘을 사용하여 스레드 간의 동기화를 유지해야 합니다.

또한, 스레드는 생명 주기(lifecycle)를 가지고 있습니다. 스레드는 생성(create), 실행(run), 대기(wait), 일시 정지(sleep), 차단(blocked), 종료(terminate) 등의 상태를 가질 수 있습니다. 프로그램에서 스레드를 효과적으로 관리하기 위해서는 이러한 상태 변화에 대한 이해와 적절한 메소드 호출이 필요합니다.

스레드는 병렬 처리, 이벤트 처리, 다중 작업 처리 등 다양한 상황에서 유용하게 사용됩니다. 그러나 스레드를 사용할 때에는 스레드 간의 동기화와 관련된 문제들에 주의해야 합니다. 잘못된 동기화는 경쟁 상태(race condition), 교착 상태(deadlock) 등의 문제를 야기할 수 있으므로 스레드를 적절하게 관리하고 동기화를 잘 구현해야 합니다.

요약하자면, 자바에서 스레드는 동시에 실행되는 작업의 단위로, 자바의 Thread 클래스를 사용하여 생성하고 실행합니다. 스레드는 독립적인 실행 경로와 스택 메모리를 가지며, 운영체제에서 스케줄링되어 실행됩니다. 스레드 간의 동기화와 상태 변화에 대한 이해와 적절한 관리가 필요하며, 잘못된 사용은 문제를 야기할 수 있습니다.
</details>
</br>

2. 스레드를 한번 구현해봐라
<details>
<summary>Thread 상속</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
#### 두 개의 스레드가 번갈아가면서 숫자를 1부터 10까지 출력하는 예제입니다.
  
```java
public class ThreadExample extends Thread {
    private String threadName;

    public ThreadExample(String name) {
        threadName = name;
    }

    public void run() {
        for (int i = 1; i <= 10; i++) {
            System.out.println(threadName + ": " + i);
            try {
                Thread.sleep(500); // 0.5초마다 출력을 일시 정지합니다.
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ThreadExample thread1 = new ThreadExample("Thread 1");
        ThreadExample thread2 = new ThreadExample("Thread 2");

        thread1.start(); // 스레드 1 시작
        thread2.start(); // 스레드 2 시작
    }
}
```
위의 예제 코드는 ThreadExample 클래스가 Thread 클래스를 상속하여 작성되었습니다. ThreadExample 클래스는 생성자를 통해 스레드의 이름을 받아옵니다. run() 메서드에서는 1부터 10까지의 숫자를 출력하고, 출력 후 0.5초 동안 일시 정지합니다.

main() 메서드에서는 ThreadExample 클래스의 인스턴스인 thread1과 thread2를 생성한 후 start() 메서드를 호출하여 각각의 스레드를 시작합니다. 스레드는 번갈아가면서 실행되며, 출력 결과에서 두 스레드가 동시에 실행되는 것을 확인할 수 있습니다.

이 예제는 스레드를 생성하고 실행하는 간단한 예시입니다. 실제로는 스레드 간의 동기화나 상호작용 등을 처리해야 하는 복잡한 상황에서 더 다양한 기능과 주의사항이 필요합니다.
         
</details>
<details>
<summary>Runnable 구현</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
#### 숫자를 역순으로 출력하는 두 개의 스레드를 생성하는 예제
```java
public class ThreadExample implements Runnable {
    private String threadName;

    public ThreadExample(String name) {
        threadName = name;
    }

    public void run() {
        for (int i = 10; i >= 1; i--) {
            System.out.println(threadName + ": " + i);
            try {
                Thread.sleep(500); // 0.5초마다 출력을 일시 정지합니다.
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ThreadExample example1 = new ThreadExample("Thread 1");
        ThreadExample example2 = new ThreadExample("Thread 2");

        Thread thread1 = new Thread(example1); // Runnable 객체로부터 스레드 생성
        Thread thread2 = new Thread(example2); // Runnable 객체로부터 스레드 생성

        thread1.start(); // 스레드 1 시작
        thread2.start(); // 스레드 2 시작
    }
}
```
위의 코드는 ThreadExample 클래스가 Runnable 인터페이스를 구현하여 작성되었습니다. ThreadExample 클래스는 생성자를 통해 스레드의 이름을 받아옵니다. run() 메서드에서는 10부터 1까지의 숫자를 역순으로 출력하고, 출력 후 0.5초 동안 일시 정지합니다.

main() 메서드에서는 ThreadExample 클래스의 인스턴스인 example1과 example2를 생성한 후, 각각의 Runnable 객체를 매개변수로 하여 Thread 클래스의 인스턴스 thread1과 thread2를 생성합니다. 그리고 start() 메서드를 호출하여 각각의 스레드를 시작합니다.

이 예제 코드는 Runnable 인터페이스를 사용하여 스레드를 생성하는 방법을 보여주고 있습니다. Runnable 인터페이스를 사용하는 경우, 다른 클래스를 상속받아야 할 필요 없이 코드의 재사용성과 유연성을 높일 수 있습니다.
</details>
</br>

3. 스레드 간의 경쟁 상태나 교착 상태를 방지하기 위한 방법은?
<details>
<summary>접기/펼치기</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
스레드 간의 경쟁 상태나 교착 상태를 방지하기 위해 다음과 같은 동기화 메커니즘을 사용할 수 있습니다:

임계 영역(Critical Section): 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 보호하기 위해 임계 영역을 정의합니다. 임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 보호됩니다. 자바에서는 synchronized 키워드를 사용하여 임계 영역을 구현할 수 있습니다.

상호 배제(Mutual Exclusion): 임계 영역에 접근하는 스레드는 상호 배제를 보장받아야 합니다. 상호 배제는 한 스레드가 임계 영역에 들어갔을 때 다른 스레드는 해당 영역에 접근할 수 없도록 제어하는 메커니즘입니다.

동기화 메소드와 동기화 블록: 자바에서는 synchronized 키워드를 사용하여 동기화 메소드 또는 동기화 블록을 정의할 수 있습니다. 동기화 메소드는 메소드 전체를 임계 영역으로 지정하고, 동기화 블록은 특정 코드 블록만을 임계 영역으로 지정합니다.

Lock과 Condition: java.util.concurrent.locks 패키지에는 Lock 인터페이스와 Condition 인터페이스가 제공됩니다. Lock 인터페이스는 lock()과 unlock() 메서드를 사용하여 임계 영역을 지정하고, Condition 인터페이스는 스레드 간의 통신을 위해 await(), signal(), signalAll() 메서드를 제공합니다. Lock과 Condition을 사용하여 더 세밀한 제어와 효율적인 스레드 동기화를 구현할 수 있습니다.

스레드 간의 협력적인 동작: 스레드 간의 협력적인 동작을 구현하여 교착 상태를 방지할 수 있습니다. 예를 들어, 스레드 A가 어떤 자원을 점유한 상태에서 스레드 B가 필요로 할 때, 스레드 A는 자원을 양보하고 대기하며, 스레드 B가 작업을 마치면 다시 자원을 가져오는 방식으로 상호 협력을 구현할 수 있습니다.

이러한 동기화 메커니즘들을 적절하게 사용하여 스레드 간의 경쟁 상태와 교착 상태를 방지할 수 있습니다. 하지만 동기화를 오용하거나 잘못 구현할 경우, 성능 저하나 데드락(deadlock) 등의 문제를 야기할 수 있으므로 주의가 필요합니다. 스레드 동기화에 관련된 복잡한 상황에서는 동시성 관리를 위한 적절한 설계와 테스트가 필요합니다.
  
**성능 저하나 데드락(deadlock) 등의 문제를 야기할 수 있으므로 주의가 필요합니다라고 이야기한 이유는 무엇인가요?**  
성능 저하나 데드락 등의 문제는 동기화를 오용하거나 잘못 구현했을 때 발생할 수 있는 문제입니다. 그 이유는 다음과 같습니다:

경합 상태(Race Condition): 경합 상태는 여러 스레드가 공유 자원에 동시에 접근하여 예기치 않은 결과를 초래하는 상황을 의미합니다. 임계 영역을 적절히 보호하지 않거나, 동기화 메커니즘이 부족하거나 잘못된 경우에 경합 상태가 발생할 수 있습니다. 경합 상태는 프로그램의 일관성을 파괴하고, 잘못된 결과를 만들어 낼 수 있으며, 디버깅이 어렵고 예측할 수 없는 동작을 초래할 수 있습니다.

데드락(Deadlock): 데드락은 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리며 무한히 대기하는 상황입니다. 각 스레드가 상대방이 점유한 자원을 요청하고 대기하면서 무한 반복되는 상태로, 프로그램이 더 이상 진행되지 못하게 됩니다. 데드락은 스레드 간의 자원 경쟁이나 동기화 메커니즘의 오류로 인해 발생할 수 있습니다. 데드락은 프로그램의 정지, 리소스 낭비, 시스템 장애 등을 야기할 수 있으며, 디버깅이 어렵고 예측할 수 없는 동작을 초래할 수 있습니다.

따라서, 동기화를 적절하게 관리하고 구현해야 하며, 경합 상태와 데드락을 방지하기 위해 스레드 간의 상호 작용을 신중하게 설계해야 합니다. 동기화 메커니즘을 정확히 이해하고 올바르게 사용하여 성능 저하와 데드락 등의 문제를 최소화할 수 있습니다.
</details>
</br>

- 
    
    어노테이션에 대해 설명해주세요
    
    - 
        
        어노테이션은 일종의 메타 데이터로, 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것입니다.
        
        대표적으로 제공하는 정보는 다음과 같습니다.
        
        1. 컴파일러가 코드 문법 에러를 찾을 수 있도록 정보를 제공합니다.
        2. 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공합니다.
        3. 실행 시 (런타임 시) 특정 기능을 실행하도록 정보를 제공합니다.
        
        어노테이션(Annotation)은 자바 프로그래밍 언어에서 코드에 메타데이터를 추가하기 위해 사용되는 기능입니다. 어노테이션은 컴파일러, 런타임 환경, 개발 도구 등에게 특정한 정보를 제공하거나 추가적인 처리를 지시하기 위해 사용됩니다.
        
        간단한 어노테이션을 구현해보겠습니다. 아래의 예제는 **`@Deprecated`** 어노테이션을 간단히 구현하는 예시입니다. **`@Deprecated`** 어노테이션은 해당 요소(클래스, 메소드, 필드 등)가 더 이상 권장되지 않는 것을 표시하는 용도로 사용됩니다.
        
        ```
        javaCopy code
        import java.lang.annotation.*;
        
        @Retention(RetentionPolicy.RUNTIME)
        @Target(ElementType.METHOD)
        public @interface Deprecated {
            String reason() default "This element is deprecated.";
        }
        
        ```
        
        위의 코드는 **`@Deprecated`** 어노테이션을 정의하는 예제입니다. **`@Retention`** 어노테이션은 어노테이션 정보가 유지되는 범위를 설정합니다. **`RetentionPolicy.RUNTIME`**은 런타임까지 어노테이션 정보가 유지되도록 설정한 것입니다. **`@Target`** 어노테이션은 어노테이션을 적용할 수 있는 대상을 설정합니다. **`ElementType.METHOD`**은 메소드에만 어노테이션을 적용할 수 있도록 설정한 것입니다.
        
        이제 위에서 정의한 어노테이션을 사용하여 메소드에 **`@Deprecated`** 어노테이션을 적용해보겠습니다.
        
        ```
        javaCopy code
        public class MyClass {
            @Deprecated(reason = "This method is deprecated.")
            public void deprecatedMethod() {
                // Deprecated method implementation
            }
        }
        
        ```
        
        위의 코드에서 **`deprecatedMethod()`** 메소드에 **`@Deprecated`** 어노테이션을 적용하였습니다. 이렇게 어노테이션을 사용하면 개발자나 도구는 해당 메소드가 더 이상 권장되지 않는다는 정보를 얻을 수 있습니다.
        
        실제로 어노테이션은 자바의 다양한 기능과 라이브러리에서 널리 사용되며, 사용자 정의 어노테이션을 생성하여 개발 환경에 맞게 사용할 수도 있습니다.
        
    
    접근 제어자는 왜 필요할까?
    
    - 
        
        그 메소드를 마음대로 호출하여 사용하면 안될 경우, 접근 제어자로 통제하여 데이터를 보호할 수 있다
        
    
    OOP의 정의와 4가지 특징
    
    - 
        
        *데이터를 객체로 취급하여 프로그램에 반영하고, 순차적으로 프로그램이 동작하는 것과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다.*
        
        추상화
        불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.
        
        캡슐화
        속성과 기능을 정의하는 멤버 변수와 메소드를 클래스라는 캡슐에 넣는 것이다. 즉, 관련된 기능(메소드)과 속성(변수)을 한 곳에 모으고 분류하기 때문에 재활용이 원활하다.
        목적 : 코드를 수정 없이 재활용하는 것
        또한, 캡슐화를 통해 정보 은닉이 가능하다.
        
        상속
        부모 클래스의 속성과 기능을 그대로 이어 받아 사용할 수 있게 하고 기능의 일부분을 변경해야 할 경우, 상속 받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.
        
        상속을 통해서 클래스를 작성하면 보다 적은 양의코드로 새로운 클래스를 작성할 수 있다.
        또한, 코드를 공통적으로 관리하여 코드 추가 및 변경이 용이하다.
        
        상속의 단점
        상위 클래스 기능에 버그가 생기거나 기능의 추가/변경 등으로 변화가 생겼을 때 상위 클래스를 상속 받는 하위 클래스가 정상적으로 작동할 수 있을지에 대한 예측이 힘듬
        
        상위 클래스에서 의미 있었던 기능이 하위 클래스에서는 의미 없는 기능일 수 있음
        
        다형성
        하나의 변수명, 함수명 등이 상황에 따라서 다른 의미로 해석될 수 있는 것이다.
        즉, 오버라이딩, 오버로딩이 가능하다
        
    
    SOLID의 5가지 특징
    
    - 
        
        ### 1 SRP 단일 책임 원칙(Single Responsibility Principle)
        
        - 한 클래스는 하나의 책임만 가져야 한다.
        - 하나의 책임은 모호
            - 클 수도 있고, 작을 수도 있다.
            - 문맥과 상황에 따라 다름
        - 중요한 기준은 변경. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
        - EX) UI 변경, 객체의 생성과 사용 분리
        
        ### 2 OCP 개방-폐쇄 원칙(Open-Closed Principle)
        
        - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함
        - 다형성을 활용
        - 인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현(변경X)''
        - 문제점
            - 클라이언트가 구현 클래스를 직접 선택
            - 구현 객체를 변경하려면 클라이언트 코드를 변경해야함..
            - 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없음
            - 해결할려면 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요
        
        ### 3 LSP 리스코프 치환 원칙(Liskov Substitution Principle)
        
        - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
        - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야함, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요.
        - EX) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능! 만약 뒤로 가게 구현했다면 LSP 위반. 느리더라도 앞으로 가게 구현해야함!
        
        ### 4 ISP 인터페이스 분리 원칙(Interface Segregation Principle)
        
        - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
        - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
        - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
        - 분리하면 장비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
        - 인터페이스가 명확, 대체 가능성이 높아짐
        
        ### 5 DIP 의존관계 역전 원칙(Dependency Inversion Principle)
        
        - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나
        - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
        - 기존의 역할과 구현에서 역할에 의존해야한다는 거랑 같음. 그래야 유연하게 구현체를 변경 가능. 구현체 의존할 경우 변경 아주 어려워짐...
    
    static이 뭔가요?
    
    - 
        
        static은 JVM 시작시 힙메모리 대신 메소드 영역에 할당되어 모든 인스턴스가 공유하게됩니다.
        
        힙 메모리가 아닌 메소드 영역 할당이면 GC가 안되나?
        
        **`static`** 멤버가 메모리에서 해제되기 위해서는 해당 멤버를 참조하는 모든 객체가 GC의 대상이 되어야 합니다.
        
    
    Java의 세 가지 변수에 대해 JVM 메모리와 연관지어 설명해주세요.
    
    - 
        
        Java에서는 세 가지 종류의 변수를 사용할 수 있습니다: 인스턴스 변수(Instance Variable), 클래스 변수(Class Variable 또는 Static Variable), 지역 변수(Local Variable).
        
        1. 인스턴스 변수: 인스턴스 변수는 객체의 인스턴스가 생성될 때마다 각 인스턴스마다 독립적으로 메모리에 할당됩니다. 이 변수들은 객체의 상태를 나타내고 객체의 수명 주기 동안 유지됩니다. 인스턴스 변수는 힙(Heap) 메모리에 저장되며, 객체가 소멸될 때까지 메모리에 유지됩니다.
        2. 클래스 변수: 클래스 변수는 해당 클래스의 모든 인스턴스들이 공유하는 변수입니다. 클래스 변수는 클래스가 로드될 때 메모리에 할당되고, 프로그램이 종료될 때까지 메모리에 유지됩니다. 클래스 변수는 모든 인스턴스가 공유하기 때문에 객체의 생성과는 관계없이 값을 유지하며, 클래스 이름으로 직접 접근할 수 있습니다. 클래스 변수는 메서드 영역(Method Area)에 저장됩니다.
        3. 지역 변수: 지역 변수는 메서드, 생성자, 블록 내에서 선언되고 해당 블록 내에서만 사용할 수 있는 변수입니다. 지역 변수는 해당 블록이 실행될 때 스택(Stack) 메모리에 할당되고, 블록 실행이 끝나면 메모리에서 제거됩니다. 지역 변수는 메서드나 블록 내에서 임시적으로 사용되는 데이터를 저장하기 위해 사용됩니다.
        
        이러한 변수들은 JVM(Java Virtual Machine)에서 관리되는 메모리 영역에 저장됩니다. 인스턴스 변수와 클래스 변수는 객체 지향 프로그램의 힙 메모리와 메서드 영역에 저장되며, 지역 변수는 스택 메모리에 저장됩니다. JVM은 메모리 관리를 담당하여 변수들을 적절히 할당하고 사용 중인 변수들의 메모리를 해제합니다.
        
    
    실행엔진이 바이트코드를 실행하는 과정
    
    - 
        
        두가지 방식을 사용하게 됩니다.
        
        - **인터프리터 방식은** 바이트코드 프로그램은 보통 한 번에 하나의 명령어를 읽은 후 실행합니다.이러한 형태의 바이트코드 인터프리터는 한 줄씩 수행하기 때문에 느립니다.
        - 인터프리터 방식의 단점을 보완하기 위해 도입된 **JIT 컴파일러**가 나왔습니다.인터프리터 방식으로 실행하다가 적절한 시점에서 바이트 코드 전체를 컴파일 하여 네이티브 코드로 변경하고, 이후에는 더이상 인터프리팅 하지 않고 네이티브 코드를 직접 실행합니다.
        - JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘었을 때, 컴파일을 수행합니다.
        - JIT 컴파일러로 인해, 자바는 네이티브 언어와 유사한 수준의 퍼포먼스를 낼 수 있게 되었습니다.
    
    JIT 컴파일러란 무엇이고, 이것은 왜 필요할까요?
    
    - 
        
        JIT(Just-In-Time) 컴파일러는 프로그램의 실행 시점에서 동작하는 컴파일러입니다. JIT 컴파일러는 프로그램 코드를 실행하기 전에 바이트 코드를 네이티브 기계 코드로 변환하여 실행 속도를 향상시킵니다.
        
        JIT 컴파일러는 프로그램의 실행 시점에서 동작하기 때문에 프로그램의 동적인 특성을 고려하여 최적화된 기계 코드를 생성합니다. 이는 프로그램이 실제로 실행되는 환경에서 발생하는 상황을 고려하여 최적화를 수행할 수 있는 장점을 가지고 있습니다.
        
        JIT 컴파일러의 필요성은 크게 두 가지 측면에서 설명할 수 있습니다:
        
        1. 실행 속도 향상: JIT 컴파일러는 바이트 코드를 네이티브 기계 코드로 변환하여 실행하기 때문에 인터프리터 방식에 비해 더 빠른 실행 속도를 제공할 수 있습니다. 또한, 프로그램의 실행 중에 동적인 최적화를 수행할 수 있어서 반복적으로 실행되는 코드의 성능을 향상시킬 수 있습니다.
        2. 플랫폼 독립성: 자바는 플랫폼 독립성을 가지는 언어로 알려져 있습니다. JIT 컴파일러는 프로그램을 실행하는 플랫폼에 맞게 기계 코드를 생성하기 때문에 다양한 플랫폼에서 동일한 자바 바이트 코드를 실행할 수 있습니다. 이는 자바의 큰 장점 중 하나입니다.
        
        따라서, JIT 컴파일러는 프로그램의 실행 속도를 향상시키고 플랫폼 독립성을 제공하는 데에 필요한 기술입니다.
        
    
    C1 컴파일러와 C2 컴파일러는 무엇일까요?
    
    - 
        
        C1 컴파일러와 C2 컴파일러는 JVM(Java 가상 머신)의 JIT(Just-In-Time) 컴파일러의 일부분입니다. 이 둘은 JVM에서 바이트 코드를 네이티브 기계 코드로 변환하는 역할을 담당하며, 실행 속도를 향상시키는 최적화를 수행합니다.
        
        1. C1 컴파일러 (Client Compiler): C1 컴파일러는 주로 빠른 컴파일 속도와 상대적으로 작은 코드 캐시 크기를 가지고 있어, JVM의 초기 구동 속도를 향상시키기 위해 사용됩니다. C1 컴파일러는 특히 작은 규모의 애플리케이션 및 클라이언트 환경에서 주로 사용됩니다.
        2. C2 컴파일러 (Server Compiler): C2 컴파일러는 보다 높은 컴파일 속도와 더 많은 최적화 기능을 가지고 있으며, 대규모 서버 환경에서 주로 사용됩니다. C2 컴파일러는 프로그램 실행 중에 동적인 프로파일링 정보를 수집하여 최적화 결정을 내리고, 더 효율적인 기계 코드를 생성합니다. C2 컴파일러는 더 많은 최적화 기법을 적용할 수 있기 때문에 더 높은 실행 속도를 제공할 수 있습니다.
        
        C1 컴파일러와 C2 컴파일러는 JIT 컴파일러의 전략 중 하나로, JVM이 실행되는 환경과 요구 사항에 따라 적절한 컴파일러를 선택하여 최적화된 코드를 생성합니다. 이를 통해 자바 애플리케이션의 실행 속도와 성능을 최대한 향상시킬 수 있습니다.
        
    
    컴파일 과정에서 컴파일러가 최적화해주는 것들은 무엇이 있을까요?
    
    - 
        
        컴파일러는 소스 코드를 기계어로 변환하는 과정에서 다양한 최적화 기법을 적용하여 실행 속도나 메모리 사용량 등을 개선할 수 있습니다. 주요한 컴파일러 최적화 기법에는 다음과 같은 것들이 있습니다:
        
        1. 상수 폴딩 (Constant Folding): 상수 표현식을 미리 계산하여 결과를 상수로 대체합니다.
        2. 공통 부분 표현식 제거 (Common Subexpression Elimination): 반복적으로 평가되는 동일한 표현식을 하나의 변수나 상수로 대체하여 계산을 줄입니다.
        3. 불필요한 코드 제거 (Dead Code Elimination): 실행되지 않는 코드를 제거하여 프로그램 크기를 줄이고 실행 속도를 향상시킵니다.
        4. 루프 최적화 (Loop Optimization): 반복문 내에서의 연산을 최적화하여 반복 횟수나 연산량을 줄입니다. 이는 인덱스 변수의 증감 연산, 반복 조건의 간략화 등을 포함합니다.
        5. 인라이닝 (Inlining): 작은 규모의 함수 호출을 함수 호출 과정 없이 직접 코드에 삽입하여 호출 오버헤드를 줄입니다.
        6. 메모리 관리 최적화 (Memory Management Optimization): 메모리 할당과 해제 작업을 최적화하여 효율적인 메모리 사용을 도모합니다. 예를 들어, 스택 메모리 사용을 통한 지역 변수의 메모리 할당과 해제는 효율적인 메모리 관리를 가능하게 합니다.
        7. 인터프로시저 최적화 (Interprocedural Optimization): 다양한 함수 간의 상호작용을 고려하여 최적화를 수행합니다. 함수 호출 관계를 분석하여 전역 최적화를 진행하고, 함수 인자 전달 방식 등을 최적화합니다.
        
        이 외에도 인덱스 재정렬, 레지스터 할당, 가상 머신 인터프리터 최적화 등 다양한 컴파일러 최적화 기법이 존재합니다. 컴파일러는 이러한 최적화 기법을 활용하여 프로그램의 실행 속도를 향상시키고, 메모리 사용량을 최소화하여 효율적인 코드를 생성합니다.
        
    
    힙에 메모리를 할당하는 과정에서 어떤 일들이 벌어지나요?
    
    - 
        
        힙에 메모리를 할당하는 과정은 다음과 같은 단계로 이루어집니다:
        
        1. 메모리 요청: 프로그램에서 힙에 할당할 메모리 크기를 요청합니다. 이 요청은 일반적으로 **`new`** 키워드를 사용하여 객체를 생성하는 과정에서 발생합니다.
        2. 할당 가능한 메모리 확인: 힙 메모리 공간에서 할당 가능한 메모리 영역을 확인합니다. 이 영역은 이전에 할당되었던 객체들이나 해제된 메모리 공간으로 구성됩니다.
        3. 메모리 할당: 요청한 크기의 메모리 블록을 할당합니다. 이 블록은 연속된 메모리 공간에 위치하며, 객체의 필드와 해당 객체에 대한 참조 등이 저장됩니다.
        4. 초기화: 할당된 메모리 블록은 초기값으로 설정됩니다. 기본적으로는 해당 타입의 기본값으로 초기화되며, 필요에 따라 개발자가 직접 초기화 작업을 수행할 수도 있습니다.
        5. 참조 연결: 객체의 참조 변수나 다른 객체들과의 연결을 설정합니다. 객체 간의 참조를 통해 객체들이 서로 연결되고, 이를 통해 프로그램에서 객체들을 접근하고 조작할 수 있습니다.
        6. 할당된 메모리 주소 반환: 할당된 메모리 블록의 시작 주소를 반환합니다. 이 주소는 참조 변수에 저장되어 해당 객체에 접근할 수 있도록 합니다.
        
        메모리 할당 과정에서는 힙 영역에서 사용 가능한 메모리 공간을 찾아야 하고, 메모리 블록의 크기에 따라 할당 위치를 결정해야 합니다. 
        
        또한, 메모리 관리를 위해 할당된 메모리의 해제 여부를 추적하고, 더 이상 필요하지 않은 메모리를 해제하여 재사용 가능하도록 관리해야 합니다. 이러한 과정을 통해 힙은 동적으로 크기가 조정되는 객체들을 관리하고, 메모리 할당과 해제를 수행합니다.
        
    
    TLAB이란 무엇일까요? 왜 만들어졌나요?
    
    - 
        
        TLAB(Thread-Local Allocation Buffer)은 Java의 힙 메모리 관리에서 사용되는 영역입니다. TLAB는 각 스레드마다 별도로 할당되는 작은 메모리 영역으로, 스레드가 객체를 생성할 때 사용됩니다.
        
        TLAB가 만들어진 이유는 다음과 같습니다:
        
        1. 멀티스레드 환경에서의 성능 개선: TLAB는 각 스레드마다 별도의 메모리 할당 영역을 제공하여 동시에 여러 스레드가 동작할 때 발생하는 메모리 할당 경합을 줄입니다. 이를 통해 스레드 간의 메모리 할당 작업이 서로 영향을 덜 주고 독립적으로 실행될 수 있습니다.
        2. 메모리 할당 속도 향상: TLAB를 사용하면 스레드는 자신의 TLAB에서 메모리를 할당받으므로 힙 영역 전체를 스캔하거나 동기화하는 비용이 줄어듭니다. 이는 메모리 할당 속도를 향상시키고, 객체 생성 작업의 지연을 줄여주는 장점이 있습니다.
        3. 메모리 사용량 최적화: TLAB는 각 스레드마다 할당되는 작은 메모리 영역이기 때문에, 필요한 만큼의 메모리만 사용하여 효율적인 메모리 관리를 할 수 있습니다. 이는 전체 힙 영역의 메모리 사용량을 최적화하는 데 도움을 줍니다.
        
        TLAB는 자바 가상 머신(JVM)에서 기본적으로 사용되는 메모리 할당 기술 중 하나입니다. TLAB를 사용함으로써 멀티스레드 환경에서의 메모리 할당 성능을 향상시키고, 메모리 사용량을 최적화할 수 있습니다.
        
    
    String 객체가 불변인 이유?
    
    - 
        
        **1. 캐싱 기능에 의한 메모리 절약과 속도 향상**
        
        - Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.
        
        **2. thread-safe**
        
        - String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.
        
        **3. 보안기능**
        
        - 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.
    
    Java에서 동일한 String을 새로 만들 때마다 객체가 생성되는지?
    
    - 
        
        Java에서 동일한 문자열 리터럴을 사용하여 String 객체를 생성할 때, 동일한 문자열을 가리키는 객체가 재사용될 수 있습니다. 이는 Java의 문자열 풀(String Pool) 개념에 의해 가능합니다.
        
        문자열 리터럴은 Java에서 상수로 취급되며, 동일한 문자열 리터럴을 사용하는 경우 JVM은 문자열 풀에서 해당 문자열을 찾아봅니다. 만약 문자열 풀에 동일한 문자열이 이미 존재한다면, JVM은 새로운 객체를 생성하지 않고 기존의 객체를 재사용합니다. 이를 문자열 리터럴 풀링(String Literal Pooling)이라고도 합니다.
        
        예를 들어, 다음과 같은 코드를 실행한다고 가정해보겠습니다:
        
        ```java
        javaCopy code
        String str1 = "Hello";
        String str2 = "Hello";
        ```
        
        위의 코드에서 **`str1`**과 **`str2`**는 동일한 문자열 리터럴 "Hello"를 참조하고 있습니다. JVM은 문자열 풀에서 해당 문자열을 검색하여 이미 존재하는 객체를 재사용합니다. 따라서 **`str1`**과 **`str2`**는 동일한 객체를 가리키게 됩니다.
        
        하지만 **`new`** 키워드를 사용하여 명시적으로 객체를 생성하는 경우에는 문자열 풀을 우회하고 새로운 String 객체가 생성됩니다. 예를 들어:
        
        ```java
        javaCopy code
        String str3 = new String("Hello");
        String str4 = new String("Hello");
        ```
        
        위의 코드에서 **`str3`**과 **`str4`**는 동일한 문자열을 가리키지만, **`new`** 키워드로 인해 새로운 String 객체가 생성됩니다. 따라서 **`str3`**과 **`str4`**는 서로 다른 객체를 가리키게 됩니다.
        
        결론적으로, Java에서는 문자열 리터럴을 사용하여 동일한 문자열을 참조하는 경우에는 객체를 재사용하여 메모리를 절약할 수 있습니다. 그러나 명시적으로 **`new`** 키워드를 사용하여 객체를 생성하는 경우에는 항상 새로운 객체가 생성됩니다.
        
    
    Java 8에 대한 기능 간략하게 설명해주세요
    
    - 
        
        ava 8은 2014년에 출시된 Java의 주요 업데이트입니다. Java 8은 다음과 같은 주요 기능들을 포함하고 있습니다:
        
        1. 람다 표현식: 람다 표현식을 사용하여 함수형 프로그래밍을 지원합니다. 람다 표현식은 익명 함수를 간결하게 표현하는 방식으로, 코드의 가독성과 유연성을 높여줍니다.
        2. 스트림 API: 스트림 API는 컬렉션을 다루는 데 사용되는 함수형 스트림을 제공합니다. 스트림은 데이터의 흐름을 처리하고 변환하는데 유용한 메서드를 제공하여 코드를 간결하게 작성할 수 있도록 합니다.
        3. 메서드 참조: 메서드 참조를 사용하여 기존의 메서드를 람다 표현식으로 간단하게 표현할 수 있습니다. 이는 코드의 가독성을 향상시키고 반복적인 코드를 줄이는 데 도움을 줍니다.
        4. 날짜 및 시간 API: Java 8에서는 새로운 날짜 및 시간 API인 **`java.time`** 패키지가 도입되었습니다. 이 API는 이전의 **`java.util.Date`** 및 **`java.util.Calendar`** 클래스보다 사용하기 쉽고 유연한 날짜 및 시간 처리를 제공합니다.
        5. 기본 메서드와 정적 메서드: Java 8에서는 인터페이스에 기본 메서드와 정적 메서드를 정의할 수 있게 되었습니다. 이를 통해 인터페이스를 변경하지 않고도 기존의 인터페이스에 새로운 기능을 추가할 수 있습니다.
        6. 병렬 처리: Java 8은 병렬 처리를 위한 새로운 기능을 도입했습니다. **`parallel()`** 메서드를 사용하여 컬렉션의 요소를 병렬로 처리할 수 있으며, 이를 통해 다중 코어를 활용하여 작업을 더 빠르게 처리할 수 있습니다.
        7. 반복자 개선: Java 8에서는 **`forEach()`** 메서드를 사용하여 반복자를 더 편리하게 처리할 수 있습니다. 이를 통해 간결한 코드로 컬렉션의 요소를 반복하고 처리할 수 있습니다.
        
        Java 8은 이 외에도 다양한 기능과 개선 사항을 포함하고 있으며, 개발자들에게 더 나은 코드 작성 경험을 제공합니다.
        
    
    Integer.MIN_VALUE에는 어떤 값이 들어가있나요? 어떤 컴퓨터에서 찍어도 동일한 값인가요?
    
    - 
        
        **`Integer.MIN_VALUE`**는 **`int`** 데이터 타입에서 표현할 수 있는 가장 작은 정수 값인 -2,147,483,648입니다. 이 값은 32비트의 부호 있는 이진수로 표현됩니다.
        
        **`Integer.MIN_VALUE`**는 Java의 정수 데이터 타입인 **`int`**의 최소값을 나타내며, 이 값은 Java 언어 명세에서 정의되어 있습니다. Java 언어 명세는 언어의 동작과 구현에 대한 표준을 정의하고 있으므로 **`Integer.MIN_VALUE`**는 Java의 모든 구현에서 동일한 값을 가지고 있어야 합니다. 즉, 어떤 컴퓨터에서 찍어도 동일한 **`-2,147,483,648`** 값이 됩니다.
        
        **`Integer.MIN_VALUE`**는 **`int`** 데이터 타입의 최소값이기 때문에, **`int`**를 벗어나는 값으로 표현되지 않습니다. 만약 더 작은 값을 표현하려면 **`long`** 데이터 타입을 사용해야 합니다.
        
    
    자바의 메모리 영역에 대해 설명
    
    - 
        
        *◦ 메서드 영역
        static 변수, 전역 변수, 코드에서 사용되는 클래스 정보들이 올라갑니다. 코드에서 사용되는 클래스들을 로더가 읽고 클래스 별로 분류해서 저장합니다.
            ◦ 스택(Stack)
        지역 변수, 메서드 등이 할당되는 LIFO 방식의 메모리입니다.
            ◦ 힙(Heap)
        new 연산자를 통해 동적할당된 객체들이 저장되고, 메모리는 가비지 컬렉션에 의해 관리됩니다.*
        
        힙 영역, 코드 영역, 스택 영역은 자바 프로그램 실행 시 사용되는 메모리 영역입니다. 각 영역의 주요 차이점은 다음과 같습니다:
        
        1. 힙 영역(Heap):
            - 동적으로 할당된 객체와 배열이 저장되는 영역입니다.
            - 프로그램의 실행 중에 동적으로 메모리를 할당하고 해제합니다.
            - 힙 영역의 크기는 프로그램 실행 시에 정적으로 결정되지 않으며, 필요에 따라 늘어날 수 있습니다.
            - 가비지 컬렉터(Garbage Collector)에 의해 관리되며, 더 이상 사용되지 않는 객체는 자동으로 해제됩니다.
        2. 코드 영역(Code):
            - 자바 프로그램의 실행 코드(바이트 코드)가 저장되는 영역입니다.
            - 프로그램의 실행 파일(.class 파일)에 포함되어 있으며, JVM이 실행할 때 메모리에 로드됩니다.
            - 코드 영역은 읽기 전용으로 할당되며, 수정할 수 없습니다.
            - JVM은 코드 영역의 명령어를 순차적으로 실행하여 프로그램의 동작을 제어합니다.
        3. 스택 영역(Stack):
            - 메소드 호출 시에 사용되는 지역 변수, 매개 변수, 메소드 호출 스택 등이 저장되는 영역입니다.
            - 메소드 호출 시마다 해당 메소드의 스택 프레임이 생성되고, 메소드의 실행이 끝나면 스택 프레임이 제거됩니다.
            - 스택 영역은 메소드 호출의 순서와 관계되며, 호출된 메소드가 실행을 마치기 전까지 메모리가 할당됩니다.
            - 스택 영역의 크기는 프로그램 실행 시에 정적으로 결정되며, 일반적으로 작은 크기의 메모리를 가집니다.
        
        이러한 메모리 영역들은 JVM에 의해 관리되며, 각각의 역할과 특성을 가지고 있어 프로그램 실행 및 메모리 관리에 중요한 역할을 수행합니다.
        
    
    병행과 병렬의 차이를 설명해주세요
    
    - 
        
        병행: 여러 일을 동시에 수행하는 것처럼 매우 짧은 시간에 번갈아가면서 수행하는 것입니다.
        
        병렬: 멀티 코어 환경에서 실제로 여러 일을 동시에 수행하는 것입니다.(core는 한가지 일밖에 처리 못하기 때문)
        
    
    스레드를 왜 써야하나요?
    
    - 
        
        스레드는 프로그램 내에서 동시에 여러 작업을 수행하기 위해 사용됩니다. 다음은 스레드를 사용해야 하는 이유입니다:
        
        1. 동시성(Concurrency): 스레드를 사용하면 여러 작업을 동시에 처리할 수 있습니다. 예를 들어, 프로그램이 동시에 여러 작업을 처리해야 할 때 스레드를 사용하면 작업을 병렬로 실행할 수 있습니다. 이는 작업의 처리 시간을 단축시키고 전체적인 성능을 향상시킬 수 있습니다.
        2. 반응성(Responsiveness): 스레드를 사용하면 프로그램이 동시에 여러 작업을 처리하면서도 사용자 입력에 빠르게 반응할 수 있습니다. 예를 들어, GUI 애플리케이션에서는 사용자의 입력을 받으면서 백그라운드에서 작업을 처리하는 스레드를 사용하여 응답성을 향상시킬 수 있습니다.
        3. 병렬 처리(Parallelism): 멀티코어 또는 멀티프로세서 시스템에서 스레드를 사용하면 여러 코어 또는 프로세서를 활용하여 작업을 병렬로 처리할 수 있습니다. 이는 대규모 계산 또는 데이터 처리 작업에서 성능을 향상시킬 수 있습니다.
        4. 비동기 처리(Asynchrony): 스레드를 사용하면 비동기적으로 작업을 처리할 수 있습니다. 이는 작업의 완료를 기다리지 않고 다른 작업을 수행할 수 있게 해주며, I/O 작업이나 네트워크 통신 등에서 유용합니다. 비동기 처리는 응답성과 처리 효율성을 향상시키는 데 도움을 줍니다.
        
        **스레드를 쓰면 동시에 여러 일을 처리할 수 있으니 한 1만개정도 띄우면 너무 좋지 않을까요?**
        
        스레드는 메모리와 CPU 시간 같은 시스템 자원을 소비합니다. 스레드를 많이 생성하면 시스템 자원을 과도하게 소비하게 되어 다른 프로세스 또는 스레드에 영향을 줄 수 있습니다. 또한, 스레드 간의 전환 비용도 발생하여 성능 저하를 가져올 수 있습니다.
        
        **사실 좋지 않은데.. 왜 좋지 않을까요? 스레드를 사용하는데에 있어 어떤 비용이 들까요?**
        
        - 메모리 양은 얼마나 들까요?
        - **컨텍스트 스위칭은 비용이 얼마나 들까요? CPU 사이클 단위로 말씀해주세요.**
        
        1. 메모리 사용량: 각 스레드는 스택 메모리와 힙 메모리를 할당받습니다. 스택 메모리는 스레드당 고정된 크기를 할당받고, 힙 메모리는 스레드에서 동적으로 할당되는 객체들을 저장하는 공간입니다. 따라서 스레드의 개수가 많을수록 전체 메모리 사용량은 증가합니다. 또한, 스레드 간에 공유되는 데이터나 자원에 따라 추가적인 메모리 사용이 발생할 수 있습니다.
        2. 컨텍스트 스위칭 비용: 컨텍스트 스위칭은 CPU가 한 스레드의 실행을 일시 중단하고 다른 스레드로 전환하는 과정입니다. 컨텍스트 스위칭에는 시간이 소요되며, 이는 CPU 사이클 단위로 측정됩니다.
        
    
    스레드 start()와 run()의 차이점이 뭔가요?
    
    - 
        
        run() 메서드는 쓰레드 내부의 run() 메서드를 호출하는 것뿐입니다. 그래서 main 메서드에서 쓰레드를 생성한 후에 run() 메서드를 호출하면 main쓰레드 내의 콜 스택에서 실행됩니다.
        
        start() 메서드는 스레드를 위한 콜 스택을 새로 생성한 후에 그 위에서 실행됩니다.
        
        콜스택: 실질적인 명령어를 담고 있는 메모리. 멀티 쓰레드는 여러개의 콜 스택을 번갈아가면서 처리하는 것.
        
    
    스레드 그룹에 대해 알고있나요?
    
    - 
        
        쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것입니다.
        
        모든 쓰레드는 반드시 쓰레드 그룹에 포함되어있고, 명시적으로 쓰레드 그룹에 포함시키지 않으면 자신을 생성한 쓰레드의 그룹에 포함됩니다.
        
    
    일반 스레드와 데몬 스레드의 차이는 뭔가요?
    
    - 
        
        일반 쓰레드는 기본적인 쓰레드(실행단위)를 뜻하고, 데몬 쓰레드는 일반 쓰레드를 도울 목적으로 만들어진 쓰레드를 뜻합니다. 대부분의 데몬 쓰레드는 무한루프를 돌며 조건문을 통해 대기하고 있다가 특정 조건이 되면 작업을 수행하고 다시 대기하는 형태로 쓰입니다. 일반 쓰레드가 다 끝나면 데몬 쓰레드도 종료되게 됩니다.
        
    
    업캐스팅과 다운캐스팅에 대해 설명해주세요
    
    - 
        
        업캐스팅과 다운캐스팅은 서로 상속관계에 있는 클래스에서 나타나며,
        
        업캐스팅은 자손 클래스 타입의 참조변수에서 조상 클래스 타입의 참조변수로 형변환,
        
        다운캐스팅은 조상 클래스 타입의 참조변수에서 자손 클래스 타입의 참조변수로 형변환 하는 것입니다.
        
    
    인터페이스와 추상클래스의  차이에 대해 설명해주세요
    
    - 
        - 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
        - 인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.
        - 공통점
            - new 연산자로 인스턴스 생성 불가능
            - 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.
        - 차이점
            - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고,
            - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
            - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.
    
    자바의 클래스 멤버 변수 초기화 순서에 대해 설명하세요
    
    - 
        
        *static 변수 선언부는 클래스가 로드 될 때 변수가 제일 먼저 초기화 됩니다.* 
        
        *필드 변수 선언부는 객체가 생성될 때 heap 메모리에 올라가고 생성자 block보다 앞서 초기화됩니다.* 
        
        *생성자 block은 객체가 생성 될 때 마찬가지로 heap 메모리에 올라가는데요. 이때 필드 변수가 초기화 될 때까지 JVM에서 내부적으로 로킹해줍니다*
        
    
    직렬화란 무엇인가요?
    
    - 
        
        자바에서 입출력을 할 때에는 `스트림`이라는 통로를 통해 데이터가 이동합니다. 하지만 `객체`는 **바이트형이 아니라서** 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없습니다.
        
        따라서 객체를 스트림을 통해 입출력하려면 `바이트 배열로 변환`하는 것이 필요한데, 이를 `'직렬화'` 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 `역직렬화`라고 합니다.
        
    
    직렬화의 포맷엔 무엇무엇이 있을까요?
    
    - 
        1. ObjectOutputStream과 ObjectInputStream 클래스를 사용하여 객체를 직렬화하고 역직렬화할 수 있습니다.
        2. JSON (JavaScript Object Notation): 인간이 읽고 쓰기 쉬운 텍스트 기반의 직렬화 포맷입니다. JSON 형식은 JavaScript에서 사용되는 객체 표기법을 기반으로 하며, 다양한 프로그래밍 언어에서 지원됩니다. 자바에서는 JSON 라이브러리인 Jackson, Gson 등을 사용하여 객체를 JSON 형식으로 직렬화하고 역직렬화할 수 있습니다.
        3. XML (eXtensible Markup Language): 텍스트 기반의 마크업 언어로 데이터를 표현하기 위한 포맷입니다. XML은 계층적인 구조로 데이터를 표현하며, 다양한 프로그래밍 언어에서 지원됩니다. 자바에서는 XML 라이브러리인 DOM, SAX, JAXB 등을 사용하여 객체를 XML 형식으로 직렬화하고 역직렬화할 수 있습니다.
        4. Protocol Buffers: 구글이 개발한 이진 직렬화 포맷입니다. Protocol Buffers는 간결하고 효율적인 데이터 교환을 위해 설계되었으며, 다양한 프로그래밍 언어에서 지원됩니다. 자바에서는 Protocol Buffers 라이브러리인 Google Protocol Buffers를 사용하여 객체를 Protocol Buffers 형식으로 직렬화하고 역직렬화할 수 있습니다.
    
    JSON의 값들이 Java 클래스에 파싱되는 과정
    
    - 
        
        위의 코드에서 **`ObjectMapper`** 객체를 생성하고, **`readValue()`** 메소드를 사용하여 JSON 데이터를 Java 객체로 변환합니다. 
        
        **`readValue()`** 메소드는 JSON 문자열과 변환할 Java 클래스를 인자로 받습니다. JSON 데이터의 필드 이름과 Java 클래스의 필드 이름이 일치하면 Jackson은 자동으로 매핑을 수행하여 Java 객체에 값을 할당합니다.
        
        위의 예시에서는 **`Person`** 클래스가 JSON 데이터와 매핑되며, **`setName()`**, **`setAge()`**, **`setCity()`** 메소드를 통해 JSON 데이터의 필드 값을 Java 객체의 필드에 설정합니다.
        
        ```java
        String json = "{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}";
        
                // ObjectMapper 객체 생성
                ObjectMapper objectMapper = new ObjectMapper();
        
                // JSON 데이터를 Java 객체로 변환
                Person person = objectMapper.readValue(json, Person.class);
        ```
        
    
    try with resource는 무엇인가요?
    
    - 
        
        try-with-resources는 `자동으로 자원을 해제해주는 기능`입니다. try에서 선언된 객체가 `AutoCloseable`을 구현하였다면 Java는 try구문이 종료될 때 객체의 `close()` 메소드를 호출해 줍니다.
        
    
    serialVersionUID를 선언해야 하는 이유는 뭔가요?
    
    - 
        
        *VM은 직렬화나 역직렬화를 하는 시점의 클래스에 대해 version 번호를 부여합니다. 그런데 만약 이 시점에서 클래스의 정의가 바뀌게 되면, version 번호도 새롭게 할당해주는데요. 직렬화와 역직렬화의 version 번호가 서로 다르면 안되기 때문에 serialVersionUID를 선언해서 문제를 해결할 수 있습니다.*
        
        *즉, 클래스 버전이 맞는지 확인하기 위한 용도로 사용된다고 말씀드릴 수 있습니다.*
        
    
    메모리 상수풀 영역에 대해 설명해보세요.
    
    - 
        
        *힙 영역에서 생성되고 자바 프로세스 종료까지 계속 유지되는 메모리 영역입니다. 기본적으로 JVM에서 관리하고 있구요. 프로그래머가 작성한 상수에 대해 최우선으로 찾아보고 없으면 상수풀에 추가한 후 그 주소값을 리턴해줍니다. 이로써 메모리 절약 효과를 가져올 수 있습니다.*
        
    
    리플렉션이란?
    
    - 
        
        *리플렉션은 컴파일러를 무시한 채 런타임 상황에서 메모리에 올라간 클래스나 메서드를 동적으로 찾아 조작할 수 있는 기능을 말합니다.*
        
        스프링에서 어노테이션 처리,의존성 주입, AOP와 같은 기능들도 리플렉션을 활용한 기술들이고 단점은 메소드 호출과 필드 접근을 위해 추가적인 메모리를 사용하게 됩니다.
        
        객체의 private에 접근할수있기 때문에 보안적으로 신경써야하고 리플렉션을 남용할 경우 읽기 어렵고 디버깅이 어려워져서 가독성과 유지보수성이 저하될 수 있습니다.
        
    
    박싱과 언박싱에 대해 설명하세요
    
    - 
        
        *원시형을 Wrapper Class로 변환하는 것이 박싱이고,*
        
        *Wrapper Class를 원시형으로 변환하는 것이 언박싱입니다.*
        
    
    데드락이 무엇이고, 해결방법에 대해 설명해보세요
    
    - 
        
        *데드락이란, 둘 이상의 스레드가 lock을 획득하기 위해 기다리는데, 이 lock을 잡고 있는 스레드도 똑같이 다른 lock을 기다리면서 서로 블락 상태에 놓이는 것을 말합니다. 데드락은 다수의 스레드가 같은 lock을 동시에 다른 명령에 의해 획득하려 할 때 발생할 수 있는데요. 해결방법으로는 우선 순위를 선정해 자원을 선점하도록 하는 것과 공유 불가능한 상호 배제 조건을 제거하는 것이 있습니다.*
        
    
    오버로딩과 오버라이딩의 차이점은?
    
    - 
        
        오버로딩 : 같은 이름의 메소드를 여러개 가지면서 매개 변수를 다르게 정의하는 것.
        
        오버라이딩 : 부모클래스가 갖고 있는 메소드를 자식클래스에서 재정의해 사용하는 것.
        
    
    자바가 가지는 장점은 무엇인가요?
    
    - 
        1. 플랫폼 독립성: 자바는 "한 번 작성하고 어디서나 실행한다"라는 원칙을 가지고 있습니다. 즉, 자바 프로그램은 운영체제나 하드웨어에 독립적으로 실행될 수 있습니다.
        2. 객체 지향 프로그래밍: 자바는 객체 지향 프로그래밍 언어로 설계되었습니다. 객체 지향적인 접근 방식은 코드의 재사용성과 유지보수성을 높여줍니다.
        3. 예외처리 안정성: 자바는 안전한 프로그래밍 환경을 제공하기 위해 설계되었습니다. 자바 가상 머신(JVM)은 악의적인 코드 실행을 제어하고, 메모리 관리 및 예외 처리를 처리하여 안정성을 강화합니다.
        4. 멀티스레딩 지원: 자바는 멀티스레드 프로그래밍을 지원하며, 쉽게 스레드를 생성하고 관리할 수 있습니다. 이는 병렬 처리 및 동시성을 구현하는 데 도움이 됩니다.
    
    int와 Integer의 차이는 무엇인가?(박싱, 언박싱) 왜 쓸데 없이 둘 다 있는걸까?
    
    - 
        
        int는 기본 데이터 타입(primitive type)이며, Integer는 int를 감싸는(wrapper) 클래스입니다. 기본 타입은 직접 값을 저장하고 메모리를 적게 사용하며, 래퍼 클래스는 객체로써 추가적인 기능과 메서드를 제공합니다.
        
        래퍼 클래스는 null 값을 받을 수 있고 자바의 제네릭 사용,
        
        int와 Integer가 모두 존재하는지에 대한 이유는 자바에서는 기본 타입과 객체 사이, 두 자료형의 호환성을 유지하기위해 기본타입을 객체로 다룰 수 있도록 박싱과 언박싱 기능을 제공해야되기때문입니다.
        
        int는 스택에 직접 값이 저장이되고 integer는 객체 이기 때문에 힙 메모리에 저장이 됩니다.
        
        만약 null을 받아야하고 제네릭 사용을 위해서라면 래퍼클래스를, 반복적인 계산과 낮은메모리 사용을 위해서라면 기본 자료형
        
    
    자바에서 String비교를 할 때 왜 ==을 사용하면 안되나요?
    
    - 
        
        자바에서 String은 객체로 다루어집니다. 따라서 문자열을 비교할 때는 문자열의 내용이 동일한지를 확인해야 합니다. 하지만 == 연산자는 객체의 참조 값을 비교하는 연산자입니다. 
        
        즉, 두 개의 String 객체를 == 연산자로 비교하면 객체의 참조 값(메모리 주소)을 비교하게 됩니다. 따라서 두 개의 String 객체가 동일한 문자열을 가지더라도 다른 메모리 위치에 저장되어 있다면 == 연산자는 false를 반환할 수 있습니다.
        
        그렇다면 equals는 뭐가 다른가요?
        
        String 클래스는 equals() 메서드를 오버라이딩하여 문자열의 내용을 비교하도록 재정의합니다. equals() 메서드는 다음과 같은 단계로 문자열 비교를 수행합니다:
        
        1. NPE 체크
        2. 비교 대상인 객체가 String 객체인지 확인
        3. 문자열의 길이를 비교
        4. 각 문자를 순차적으로비교
    
    equals를 재정의할때 hashcode도 재정의하는 이유는 무엇인가요?
    
    - 
        
        ```java
        public static void main(String[] args) {
            Set<Car> cars = new HashSet<>();
            cars.add(new Car("foo"));
            cars.add(new Car("foo"));
        
            System.out.println(cars.size());
        }
        ```
        
        hashCode를 equals와 함께 재정의하지 않으면 코드가 예상과 다르게 작동하는 위와 같은 문제를 일으킨다. 정확히 말하면 **hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 문제가 발생한다.**
        
        hash값을 사용하는 collection은 객체가 논리적으로 같은지 비교할때 아래와 같은 과정을 거친다.
        
        ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1,%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%207025ec5fc38d43dcaa213e01af9b519f/Untitled%201.png)
        
        hashCode 메서드의 리턴 값이 우선 일치하고 equals 메서드의 리턴 값이 true여야 논리적으로 같은 객체라고 판단한다.
        
        Car 클래스에는 hashCode 메서드가 재정의 되어있지 않아서 Object 클래스의 hashCode 메서드가 사용되었다.
        
        Object 클래스의 hashCode 메서드는 객체의 고유한 주소 값을 int 값으로 변환하기 때문에 객체마다 다른 값을 리턴한다. 두 개의 Car 객체는 equals로 비교도 하기 전에 서로 다른 hashCode 메서드의 리턴 값으로 인해 다른 객체로 판단된 것이다.
        
        재정의
        
        ```java
        @Override
            public int hashCode() {
                return Objects.hash(name);
            }
        ```
        
        Objects.hash 메서드는 hashCode 메서드를 재정의하기 위해 간편히 사용할 수 있는 메서드이지만 속도가 느리다. 인자를 담기 위한 배열이 만들어지고 인자 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다.
        
        성능에 아주 민감하지 않은 대부분의 프로그램은 간편하게 Objects.hash 메서드를 사용해서 hashCode 메서드를 재정의해도 문제 없다.
        
        ****무조건 같이 재정의해줘야 할까?****
        
        ‘hash 값을 사용하는 Collection을 사용 하지 않는다면, equals와 hashCode를 같이 재정의하지 않아도 되는건가?‘
        
        요구사항은 항상 변한다. hash 값을 사용하는 Collection을 사용할 리 없다는 자신의 판단은 틀렸을 가능성이 높다.
        또, 협업 환경이라면 동료는 당연히 equals와 hashCode를 같이 재정의했을 거라고 생각하고 hash 값을 사용하는 Collection으로 수정할 가능성도 있다.
        
        굳이 이런 위험한 코드를 안고 가지말고 equals와 hashCode는 항상 같이 재정의해주는 게 맞다고 생각한다.
        
    
    shallow copy, deep copy에 대해 설명해주세요
    
    - 
        
        Shallow copy는 객체를 복사할 때, 해당 객체의 주소를 복사하는 방식입니다. 이는 새로운 객체를 생성하되, 객체 내부의 필드들은 원본 객체와 동일한 메모리 주소를 참조하게 됩니다. 따라서 객체의 변경 사항은 복사된 객체와 원본 객체에 모두 영향을 미칩니다
        
        ```java
        class Person {
            private String name;
            
            public Person(String name) {
                this.name = name;
            }
            
            public String getName() {
                return name;
            }
        }
        
        // 객체 생성 및 얕은 복사
        Person person1 = new Person("Alice");
        Person person2 = person1; // 얕은 복사
        
        System.out.println(person1.getName()); // 출력: Alice
        System.out.println(person2.getName()); // 출력: Alice
        
        person2.setName("Bob"); // person2의 이름 변경
        
        System.out.println(person1.getName()); // 출력: Bob
        System.out.println(person2.getName()); // 출력: Bob
        ```
        
        Deep copy는 객체를 복사할 때, 객체의 필드들을 재귀적으로 복사하는 방식입니다. 이는 새로운 객체를 생성하고, 객체 내부의 필드들도 독립적으로 새로운 메모리 공간에 복사됩니다. 따라서 객체의 변경 사항은 복사된 객체와 원본 객체 간에 서로 영향을 주지 않습니다.
        
        ```java
        class Person {
            private String name;
            
            public Person(String name) {
                this.name = name;
            }
            
            public String getName() {
                return name;
            }
            
            public void setName(String name) {
                this.name = name;
            }
        }
        
        // 객체 생성 및 깊은 복사
        Person person1 = new Person("Alice");
        Person person2 = new Person(person1.getName()); //
        ```
        
    
    자바에서 Integer a = 1; if(a==1)과 같은 코드가 동작하는 이유
    
    - 
        
        Integer는 객체 타입이지만, 자바에서는 일부 기본 타입(primitive type)에 대해 자동으로 객체로 변환해주는 오토박싱 기능을 제공합니다. 즉, 정수 값 1은 int 타입의 리터럴이지만, 컴파일러가 자동으로 Integer 객체로 변환하여 할당합니다.
        
    
    call by reference vs call by value
    
    - 
        1. Call by Reference:
        Call by Reference는 메서드 호출 시, 인자로 전달되는 변수의 메모리 주소(reference)를 전달하는 방식입니다. 즉, 메서드 내에서 해당 변수의 값 뿐만 아니라 변수 자체에 대한 변경도 가능합니다. 이는 메모리 주소를 공유하기 때문에 메서드 내에서 변수의 값을 변경하면 원본 변수의 값도 함께 변경됩니다.
        2. Call by Value:
        Call by Value는 메서드 호출 시, 변수의 값을 복사하여 전달하는 방식입니다. 이는 변수의 값 자체를 전달하므로, 메서드 내에서 변수의 값을 변경해도 원본 변수의 값은 변경되지 않습니다.
        
        자바는 "call by value"로 동작합니다. 이는 변수의 값을 복사하여 메서드에 전달하는 방식입니다. 기본 타입의 경우 값 자체를 복사하고, 참조 타입의 경우 객체의 참조 값(메모리 주소)를 복사하여 전달합니다. 따라서 자바에서 메서드 내에서 전달된 변수의 값 변경은 원본 변수에 영향을 주지 않습니다.
        
        ```java
        void modifyValue(int value) {
            value = 10; // 값 변경
        }
        
        void modifyObject(Person person) {
            person.setName("Alice"); // 객체의 상태 변경
        }
        
        public static void main(String[] args) {
            int num = 5;
            modifyValue(num);
            System.out.println(num); // 출력: 5
        
            Person p = new Person("John");
            modifyObject(p);
            System.out.println(p.getName()); // 출력: Alice
        }
        ```
        
        위 코드에서 modifyValue() 메서드는 기본 타입인 int를 인자로 받고, modifyObject() 메서드는 참조 타입인 객체를 인자로 받습니다. 하지만 메서드 내에서 값을 변경하더라도 원본 변수에는 영향을 주지 않고, 객체의 상태를 변경할 수 있습니다. 이는 자바의 "call by value" 동작 방식입니다.
        
    
    자바가 소스코드에서 실행되는 과정을 설명해주세요
    
    - 
        1. 소스코드 작성: 개발자가 자바 프로그램을 작성하기 위해 텍스트 에디터 등을 사용하여 자바 소스코드를 작성합니다. 자바 소스코드는 **`.java`** 확장자를 가지며, 클래스, 메소드, 변수 등의 정의와 로직을 포함합니다.
        2. 컴파일(Compile): 작성한 소스코드를 컴파일러를 통해 기계어로 변환합니다. 자바 컴파일러(javac)는 소스코드를 읽어들여서 바이트코드(Bytecode)로 변환합니다. 바이트코드는 JVM이 실행할 수 있는 중간 형태의 이진 파일로, **`.class`** 확장자를 가지며 플랫폼에 독립적입니다.
        3. 클래스 로딩(Class Loading): 컴파일된 바이트코드를 실행하기 위해 JVM은 클래스 로더를 사용하여 필요한 클래스 파일들을 로드합니다. 클래스 로더는 클래스 파일을 찾고, 메모리에 로드하고, 링크 작업을 수행합니다.
        4. 바이트코드 검증(Verification): JVM은 로드된 클래스 파일의 유효성을 검증합니다. 바이트코드 검증 단계에서는 클래스 파일이 올바른 형식을 따르고, 자바의 안전성 규칙을 준수하는지 등을 확인합니다.
        5. 바이트코드 해석(Interpretation) 또는 JIT 컴파일: JVM은 로드된 클래스 파일의 바이트코드를 해석하거나, 필요에 따라 Just-In-Time(JIT) 컴파일러를 사용하여 네이티브 기계어로 변환합니다. 네이티브 기계어는 해당 플랫폼에서 직접 실행될 수 있는 형태의 코드입니다.
        6. 실행(Execution): 변환된 네이티브 기계어 코드가 JVM 상에서 실행됩니다. JVM은 메모리 관리, 스레드 관리, 예외 처리 등의 기능을 제공하며, 프로그램의 실행을 관리합니다. 실행 중에는 메소드 호출, 객체 생성, 데이터 처리 등이 이루어집니다.
        7. 프로그램 종료: 프로그램이 정상적으로 실행을 마치거나, 예외가 발생하거나, 명시적으로 종료되면 프로그램이 종료됩니다. 이때 JVM은 사용한 자원들을 정리하고 메모리를 해제합니다.
    
    클래스 로더 동작 과정
    
    - 
        1. 가장 먼저, 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
        2. 그 다음, 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.
        3. 검사 후에는, 필드, 메서드, 인터페이스 등 메서드클래스가 필요로 하는 메모리를 할당합니다.
        4. 이 후, 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.
        5. 마지막으로 클래스 변수들을 적절한 값으로 초기화합니다.
    
    JVM의 메모리 구조에 대해서 최대한 자세히 설명해주세요
    
    - 
        
        JVM(Java Virtual Machine)의 메모리 구조는 크게 세 가지 부분으로 나눌 수 있습니다: 메소드 영역(Method Area 또는 Class Area), 힙(Heap), 스택(Stack)입니다. 각 영역의 역할과 특징은 다음과 같습니다:
        
        1. 메소드 영역(Method Area 또는 Class Area):
            - 클래스에 대한 정보를 저장하는 공간입니다.
            - JVM이 시작될 때 생성되며, JVM이 종료될 때까지 유지됩니다.
            - 클래스의 구조, 상수, 정적 변수, 메소드 코드 등이 저장됩니다.
            - 여러 스레드가 공유하는 영역입니다.
        2. 힙(Heap):
            - 동적으로 생성된 객체가 저장되는 공간입니다.
            - 클래스의 인스턴스, 배열 등의 객체가 할당됩니다.
            - 가비지 컬렉터에 의해 관리되며, 더 이상 사용되지 않는 객체는 자동으로 해제됩니다.
            - 여러 스레드가 공유하는 영역입니다.
        3. 스택(Stack):
            - 메소드 호출과 관련된 정보를 저장하는 공간입니다.
            - 메소드 호출 시마다 프레임(Frame)이 생성되고, 해당 프레임은 메소드의 매개변수, 지역 변수, 임시 데이터 등을 저장합니다.
            - 메소드의 실행이 끝나면 해당 프레임이 스택에서 제거됩니다.
            - 각 스레드마다 별도의 스택을 가지며, 스레드 사이에는 스택이 독립적으로 존재합니다.
        
        힙과 스택은 메모리가 동적으로 할당되는 영역으로, JVM이 실행 중에 메모리를 동적으로 관리합니다. 힙은 객체의 생성과 해제가 이루어지는 영역으로, 가비지 컬렉터에 의해 더 이상 사용되지 않는 객체가 자동으로 해제됩니다. 
        
        스택은 메소드 호출과 관련된 정보를 저장하는 영역으로, 메소드의 호출과 종료에 따라 프레임이 생성되고 제거됩니다. 메소드의 매개변수, 지역 변수, 임시 데이터 등이 스택 프레임에 저장됩니다.
        
    
    JVM의 힙은 어떤 구조로 이루어져있나요?
    
    - 
        
        JVM의 힙(Heap)은 크게 세 가지 영역으로 구성되어 있습니다. 이 세 가지 영역은 Young Generation, Old Generation, Perm(또는 Metaspace) Generation입니다. 각 영역의 역할과 특징은 다음과 같습니다:
        
        1. Young Generation:
            - 새로 생성된 객체가 할당되는 영역입니다.
            - 대부분의 객체는 Young Generation에 할당됩니다.
            - Young Generation은 또 다시 세 영역으로 구성되는데, Eden 영역과 두 개의 Survivor 영역(S0, S1)으로 나뉩니다.
            - 새로 생성된 객체는 Eden 영역에 할당되며, 일정 시간 이상 살아남은 객체는 Survivor 영역으로 이동됩니다.
            - Minor GC(Young Generation GC)는 Eden 영역과 Survivor 영역 사이에서 수행되어 더 이상 참조되지 않는 객체를 제거합니다.
        2. Old Generation:
            - Young Generation에서 일정 시간 동안 살아남은 객체가 이동하는 영역입니다.
            - Young Generation보다 오래 살아남은 객체들이 저장됩니다.
            - Old Generation에는 대용량의 객체나 오랜 시간동안 살아남은 객체들이 할당됩니다.
            - Major GC(Old Generation GC 또는 Full GC)는 Old Generation에서 실행되어 더 이상 사용되지 않는 객체를 제거합니다.
        3. Perm(또는 Metaspace) Generation:
            - 클래스와 메소드, 상수 풀 등의 메타데이터가 저장되는 영역입니다.
            - JVM 7 이전 버전에서는 Perm Generation으로 알려져 있었지만, JVM 8부터는 Perm Generation 대신 Metaspace라는 새로운 영역으로 변경되었습니다.
            - Perm(또는 Metaspace) Generation은 클래스 로딩과 언로딩, 메소드와 상수 정보 등을 저장합니다.
            - Perm Generation은 고정 크기로 할당되지 않고, 필요에 따라 동적으로 크기가 조정됩니다.
        
        이렇게 구성된 힙은 객체의 수명 주기에 따라 영역을 나누어 관리하여 메모리를 효율적으로 사용하고 가비지 컬렉션을 수행합니다. 
        
        Young Generation에서는 객체의 생성과 제거가 빈번하게 일어나며, Minor GC가 주기적으로 실행됩니다. 
        
        Old Generation에서는 오래된 객체가 보관되며, Major GC가 필요한 경우에 실행됩니다. 
        
        Perm(또는 Metaspace) Generation은 클래스와 관련된 정보를 저장하는 영역으로, Perm/Metaspace GC는 클래스 로딩과 언로딩에 따라 메모리를 관리합니다.
        
    
    GC에 대해 아는대로 설명해주세요 단점도 같이요.
    
    - 
        
        GC(Garbage Collection)은 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 객체, 즉 가비지(Garbage)를 자동으로 찾아서 해제하는 작업입니다.
        
        GC의 목적은 메모리 누수를 방지하고, 사용되지 않는 객체를 해제하여 메모리를 효율적으로 관리하는 것입니다. GC는 JVM에 의해 자동으로 수행되며, 개발자가 직접 메모리 관리를 신경쓰지 않아도 됩니다.
        
        **Reachability(도달 가능성)**를 기준으로 어떤 경로를 통해 변수나 필드로 참조되는 객체는 도달하고 나머지 객체는 가비지로 간주합니다. 
        
        GC의 단점또한 존재합니다.
        
        1. **Stop-the-World 시간**:
            - 대부분의 GC 알고리즘은 Stop-the-World 방식을 사용하여 가비지 컬렉션을 실행합니다. 이는 가비지 컬렉션 작업이 진행되는 동안 애플리케이션의 모든 스레드가 일시적으로 멈추는 것을 의미합니다. Stop-the-World 시간이 길어질수록 애플리케이션의 반응성이 저하될 수 있습니다.
        2. **자원 소모**:
            - GC는 시스템 리소스를 사용합니다. 가비지 컬렉션 작업은 CPU 시간과 메모리 대역폭을 소모하며, 큰 힙 영역의 가비지 컬렉션은 많은 시간을 소요할 수 있습니다. 이는 애플리케이션의 성능에 영향을 줄 수 있습니다.
        3. **메모리 파편화**:
            - GC 작업 중에 메모리 할당과 해제가 반복되면 메모리 파편화가 발생할 수 있습니다. 메모리 파편화는 가용한 연속 메모리 공간의 부족을 초래하고, 이로 인해 새로운 객체의 할당이 어려워질 수 있습니다. 이는 GC 작업 이후에도 메모리 사용량이 증가할 수 있는 원인이 됩니다.
        4. **GC 부담**:
            - GC는 애플리케이션의 실행 시간과 상관없이 일정 주기로 발생하며, 이는 시스템에 부담을 줄 수 있습니다. GC 작업이 빈번하게 발생하거나 GC의 작업량이 많을 경우, 애플리케이션의 성능에 영향을 미칠 수 있습니다.
        5. **객체 수명 추적 오버헤드**:
            - GC는 객체의 도달 가능성을 추적하기 위해 추가적인 메모리 및 연산 오버헤드를 발생시킵니다. 도달 가능한 객체를 식별하기 위해 객체에 대한 참조 체인을 추적하고 관리해야 합니다. 이는 GC의 성능에 영향을 줄 수 있으며, 복잡한 참조 구조를 가진 애플리케이션에서 더 큰 오버헤드를 발생시킬 수 있습니다.
        
    
    GC가 어떻게 가비지를 자동으로 찾아낼수있죠?
    
    - 
        
        GC는 JVM이 일정 시간마다 호출하는 것이 아니라, JVM이 가비지 컬렉션이 필요한 상황을 판단하여 호출합니다. JVM은 여러 가비지 컬렉션 알고리즘을 사용하며, 각 알고리즘은 가비지 컬렉션을 수행하는 타이밍을 다르게 결정합니다.
        
        보통 JVM은 다음과 같은 상황에서 가비지 컬렉션을 수행합니다:
        
        1. **Young Generation 영역의 공간 부족**: Young Generation은 객체가 생성되고 사용되는 영역으로, 일반적으로 객체의 수명이 짧은 특성을 가집니다. Young Generation이 가득 차게 되면 Minor GC(Young Generation에서의 가비지 컬렉션)가 발생하여 가비지를 제거합니다.
        2. **Old Generation 영역의 공간 부족**: Old Generation은 Young Generation에서 살아남은 객체들이 복사되어 옮겨지는 영역입니다. Old Generation이 가득 차게 되거나 일부 공간만 사용 가능한 경우에는 Major GC 또는 Full GC(전체 힙 영역에서의 가비지 컬렉션)가 발생하여 가비지를 제거합니다.
        3. **CPU 사용량 및 시스템 상태**: JVM은 CPU 사용량이 일정 수준을 초과하거나 시스템 부하가 증가한 경우에도 가비지 컬렉션을 수행할 수 있습니다. 이는 시스템 리소스의 효율적인 관리를 위해 가비지 컬렉션 작업을 조절하는 데 도움을 줍니다.
        
        따라서, JVM은 객체의 생성 및 사용 패턴, 메모리 상태, 시스템 리소스 상황 등을 고려하여 적절한 타이밍에 가비지 컬렉션을 수행합니다.
        
        GC가 가비지를 찾아내는 과정은 다음과 같습니다:
        
        1. **Reachability(도달 가능성) 판별**: GC는 가비지 수집 대상인 객체를 식별하기 위해 도달 가능성을 판별합니다. 도달 가능한 객체는 GC의 대상이 아니며, 도달할 수 없는 객체가 가비지로 판단됩니다. 도달 가능성은 GC 루트(예: 스택 프레임, 정적 변수)에서부터 시작하여 객체 간의 참조 체인을 따라가며 판별됩니다.
        2. **Marking(표시)**: GC는 도달 가능한 객체들을 표시합니다. 이 단계에서 GC는 도달 가능한 객체를 특별한 플래그나 비트로 표시하여 메모리 상에서 식별합니다. 표시된 객체는 가비지가 아니라고 판단됩니다.
        3. **Sweeping(정리)**: 표시된 객체 이외의 객체들은 가비지로 간주됩니다. GC는 표시되지 않은 객체들을 찾아내고, 해당 객체들이 차지하던 메모리를 회수합니다. 이 단계에서 가비지 객체의 메모리는 해제되고 다음에 사용할 수 있는 상태가 됩니다.
        4. **Compact(압축)** (일부 GC 알고리즘에서만): Compact 단계는 메모리 조각화를 줄이고 힙 영역의 메모리를 연속적으로 재배치하는 단계입니다. 이 단계는 메모리 사용 효율성을 향상시키고 가비지 컬렉션 이후에도 힙 영역을 효율적으로 사용할 수 있도록 합니다.
        
        GC는 위의 과정을 반복적으로 수행하여 가비지 객체를 찾아내고 메모리를 회수합니다. 이를 통해 개발자는 명시적으로 메모리 관리를 수행하지 않아도 되며, 자동으로 가비지 컬렉션이 수행되어 메모리 누수를 방지할 수 있습니다.
        
    
    GC에서 리전으로 구성된 구조가 왜 튜닝의 수고를 덜어주는걸까요?
    
    - 
        
        리전 구조를 사용하는 GC 알고리즘 중 하나는 "G1 (Garbage-First)" GC 알고리즘입니다. G1 GC는 Java SE 7부터 도입된 가비지 컬렉션 알고리즘으로, 전체 힙을 작은 리전으로 분할하고 각 리전에 대해 가비지 컬렉션을 수행합니다. 
        
        G1 GC는 부분적인 GC 실행, 선택적인 GC 대상 선택, 지연된 가비지 컬렉션 등의 특징을 가지고 있습니다. 이를 통해 G1 GC는 큰 힙 영역에서도 빠른 응답성과 좋은 메모리 사용 효율성을 제공할 수 있습니다.
        
        GC에서 리전(region)으로 구성된 구조는 가비지 컬렉션의 효율성과 튜닝에 도움을 줄 수 있습니다. 다음은 리전 구조의 장점입니다:
        
        1. **부분적인 GC 실행**: 리전 구조는 전체 힙 영역을 하나의 단일 단위로 처리하는 대신, 작은 리전으로 분할하여 가비지 컬렉션을 수행합니다. 이는 전체 힙을 대상으로 하는 대규모 Stop-the-World 시간을 줄일 수 있습니다. 대신, 리전 단위로 가비지 컬렉션을 수행하여 일부 리전만 처리하고, 다른 리전은 애플리케이션 실행과 동시에 작업이 진행될 수 있습니다.
        2. **선택적인 GC 대상**: 리전 구조에서는 가비지 컬렉션의 대상이 될 리전을 선택적으로 결정할 수 있습니다. 즉, 전체 힙 영역을 한 번에 처리하는 것이 아니라, 필요에 따라 특정 리전만 선택하여 GC를 수행할 수 있습니다. 이는 애플리케이션의 동작 패턴에 따라 가비지 컬렉션 작업을 제어하고 튜닝할 수 있는 유연성을 제공합니다.
        3. **지연된 가비지 컬렉션**: 리전 구조에서는 가비지 컬렉션 작업을 지연시킬 수 있습니다. 모든 리전을 동시에 처리하지 않고, 필요한 리전에 대해서만 가비지 컬렉션을 실행하거나 가비지 컬렉션 작업을 일정 시간 동안 연기할 수 있습니다. 이는 애플리케이션의 응답성을 향상시키고, 특정 작업 부하 시나리오에 대해 가비지 컬렉션의 부담을 분산시킬 수 있습니다.
        4. **공간 효율성**: 리전 구조에서는 리전 단위로 메모리를 할당하고 해제할 수 있으므로, 메모리 공간의 효율성을 높일 수 있습니다. 작은 리전 단위로 메모리를 할당하고 해제하면서, 메모리 파편화를 줄일 수 있습니다. 이는 메모리 사용량을 최적화하고, 가비지 컬렉션 작업의 오버헤드를 감소시킬 수 있습니다.
        
        리전 구조는 일부 GC 알고리즘에서 사용되며, 특히 멀티스레드 환경에서 가비지 컬렉션의 성능과 응답성을 개선하는 데 도움이 됩니다. 이러한 이점들은 GC의 튜닝과 최적화에 더 많은 유연성과 효율성을 제공합니다.
        
    
    자바8은 무슨 GC를 사용하나요?
    
    - 
        
        자바 8에서 기본적으로 사용되는 GC 알고리즘은 "Parallel GC"입니다. Parallel GC는 멀티스레드 환경에서 가비지 컬렉션을 수행하는 병렬 GC 알고리즘입니다. Parallel GC는 Young Generation과 Old Generation을 모두 병렬로 처리하여 가비지 컬렉션 작업을 효율적으로 수행합니다.
        
        Parallel GC는 Young Generation에는 "Minor GC"라고도 불리는 작은 범위의 가비지 컬렉션을 수행하고, Old Generation에는 "Major GC" 또는 "Full GC"라고도 불리는 전체 힙 영역의 가비지 컬렉션을 수행합니다. Parallel GC는 다른 GC 알고리즘들에 비해 빠른 가비지 컬렉션 작업을 제공하며, 멀티코어 시스템에서 병렬 처리를 통해 성능을 향상시킬 수 있습니다.
        
        Parallel GC는 기본적으로 사용되는 GC 알고리즈로 Java 8에서는 -XX:+UseParallelGC 옵션을 통해 활성화할 수 있습니다. 하지만 Java 8에서는 -XX:+UseG1GC 옵션을 사용하여 G1 GC를 선택적으로 사용할 수도 있습니다. 따라서, 사용하는 JVM 구성 및 설정에 따라 기본 GC 알고리즘이 달라질 수 있습니다.
        
    
    이전 GC의 메모리 구조와 G1GC의 메모리 구조를 비교해보고, GC튜닝을 하는 궁극적인 목표는 무엇인가요?
    
    - 
        
        이전 GC의 메모리 구조와 G1 GC의 메모리 구조를 비교하고 GC 튜닝의 궁극적인 목표에 대입하여 설명하면 다음과 같습니다:
        
        **이전 GC의 메모리 구조**:
        
        - 이전 GC(Garbage-First GC 이전의 기본 GC 알고리즘)에서는 힙을 Young Generation과 Old Generation으로 나누었습니다.
        - Young Generation은 객체가 생성되고 사용되는 영역이며, Eden 영역과 두 개의 Survivor 영역으로 구성되었습니다.
        - Old Generation은 Young Generation에서 살아남은 객체들이 복사되어 옮겨지는 영역입니다.
        - Young Generation에서 가비지 컬렉션이 발생하면 살아남은 객체들은 Survivor 영역으로 이동하고, 일정 시간이 지나면 Old Generation으로 이동합니다.
        - Old Generation에서 가비지 컬렉션이 발생하면 전체 힙 영역에서 가비지를 제거합니다.
        
        **G1 GC의 메모리 구조**:
        
        - G1 GC는 힙을 작은 리전(Region)으로 분할합니다.
        - 각 리전은 Young Region과 Old Region으로 구성됩니다.
        - Young Region은 Young Generation 역할을 하고, Old Region은 Old Generation 역할을 합니다.
        - 리전은 동적으로 크기가 조정되며, 여러 개의 리전이 함께 사용됩니다.
        - G1 GC는 가장 먼저 가비지가 많은 리전을 우선적으로 수집하는 "Garbage-First" 접근 방식을 채택합니다.
        
        **GC 튜닝의 궁극적인 목표**:
        
        - GC 튜닝의 궁극적인 목표는 애플리케이션의 성능을 최적화하고 응답성을 향상시키는 것입니다.
        - 이를 위해 GC의 정지 시간(stop-the-world)을 최소화하여 애플리케이션의 작업을 지연시키지 않는 것이 중요합니다.
    
    Maven, Gradle에 대해 설명해주세요
    
    - 
        
        **Maven:**
        
        - XML 기반의 프로젝트 설정 파일을 사용합니다.
        - Convention over Configuration 원칙에 따라 프로젝트 구조와 빌드 라이프사이클이 미리 정의되어 있습니다.
        - 중앙 집중식 리포지토리(중앙 저장소)를 통해 의존성 관리와 프로젝트 종속성 관리가 용이합니다.
        - 기본 설정이 간단하고 사용하기 쉽습니다.
        - 다양한 플러그인과 확장성이 있으며, 표준화된 빌드 라이프사이클과 명령어를 제공합니다.
        - 그러나 XML 설정 파일의 가독성이 떨어지고 복잡해질 수 있으며, 일부 고급 기능을 구현하기 어려울 수 있습니다.
        
        **Gradle:**
        
        - Groovy 기반의 도메인 특화 언어(Domain Specific Language, DSL)를 사용하여 프로젝트를 설정합니다.
        - 유연하고 간결한 DSL 문법을 통해 프로젝트 구성과 빌드 스크립트 작성이 용이합니다.
        - 런타임에 스크립트를 평가하므로 동적인 빌드 구성이 가능합니다.
        - Maven과 호환성을 지원하며, 기존 Maven 프로젝트를 Gradle로 마이그레이션하기 쉽습니다.
        - 멀티 프로젝트 빌드에 용이하며, 빌드 캐시 기능 등 성능 향상을 위한 다양한 기능을 제공합니다.
        - 그러나 초기 설정이 상대적으로 복잡하고, 다양한 플러그인의 버전 호환성 문제가 있을 수 있습니다.
        
        Maven은 전통적인 방식의 빌드 도구로 널리 사용되고 있으며, 기존 Maven 프로젝트와의 호환성이 중요한 경우에 적합합니다. 
        
        반면에 Gradle은 더 유연하고 강력한 스크립트 기반의 빌드 도구로, 복잡한 프로젝트 구성이나 고급 기능을 필요로 하는 경우에 선호됩니다. 선택은 프로젝트의 특성과 개발자의 선호도에 따라 달라집니다.
        
    
    객체지향이란 무엇인가요?
    
    - 
        
        현실 세계의 개념을 프로그래밍에 반영하는 방법입니다. 객체지향은 협력, 책임, 역할과 같은 키워드가 중요한 개념들을 가지고 있습니다.
        
        **1. 객체지향의 기본 개념:**
        
        - **객체(Object)**: 실제 세계의 개체(Entity) 또는 개념을 나타내는 소프트웨어 요소입니다. 객체는 상태(State), 행위(Behavior), 식별자(Identity)를 가집니다.
        - **클래스(Class)**: 객체를 생성하기 위한 템플릿 또는 설계도입니다. 클래스는 객체의 상태와 행위를 정의하며, 객체들 간에 공통된 특징과 동작을 공유할 수 있게 합니다.
        - **인스턴스(Instance)**: 클래스로부터 생성된 실제 객체를 의미합니다. 클래스는 인스턴스화되어야만 메모리에 할당되고 사용될 수 있습니다.
        
        ****클래스 vs 객체 = 붕어빵틀 vs 붕어빵?****
        
        클래스와 객체는 **분류와 사물**의 관계여야 한다
        
        **2. 객체지향의 주요 개념:**
        
        - **협력(Collaboration)**: 객체들 간의 상호작용을 통해 문제를 해결하는 것입니다. 객체들은 서로 메시지(Message)를 주고받으며, 각자의 책임을 수행하고 협력하여 원하는 결과를 얻습니다.
        - **책임(Responsibility)**: 객체가 어떤 행위를 수행하거나 정보를 처리할 의무를 가지는 것을 말합니다. 책임은 객체의 역할(Role)과 관련되며, 객체는 자신의 책임을 다하기 위해 필요한 행위와 데이터를 가지고 있어야 합니다.
        - **역할(Role)**: 객체들이 협력 속에서 수행하는 특정한 책임의 집합입니다. 여러 객체는 동일한 역할을 수행할 수 있으며, 역할에 따라 객체 간의 교체가 가능해야 합니다.
        - **다형성(Polymorphism)**: 동일한 메시지를 받는 객체들이 각각의 역할에 따라 다르게 행동하는 것을 말합니다. 다형성은 객체의 교체 가능성을 높이고 유연한 코드를 작성할 수 있게 합니다.
        
        **3. 객체지향의 장점:**
        
        - **모듈화(Modularity)**: 객체는 독립적인 모듈로 구성되어 있으며, 객체 간의 인터페이스를 통해 상호작용합니다. 이로써 코드의 재사용성과 유지보수성이 향상됩니다.
        - **캡슐화(Encapsulation)**: 객체는 데이터와 그를 처리하는 메서드를 하나로 묶어 캡슐화합니다. 캡슐화를 통해 데이터의 접근을 제어하고 외부에서의 직접적인 접근을 방지할 수 있습니다.
        - **상속(Inheritance)**: 상속을 통해 기존 클래스의 특징을 재사용하고 확장할 수 있습니다. 상속을 통해 코드의 중복을 줄이고 일관성을 유지할 수 있습니다.
        - **다형성(Polymorphism)**: 다형성을 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다. 다형성은 코드의 가독성과 유지보수성을 높여줍니다.
        
        객체지향은 문제를 좀 더 직관적이고 모델링하기 쉽게 만들어주며, 코드의 재사용성과 확장성을 높여줍니다. 또한 협력과 역할 중심의 개발 방식으로 복잡한 시스템을 구성할 때 유용합니다.
        
        *객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다.*
        
        추상화
        불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.
        
        캡슐화
        속성과 기능을 정의하는 멤버 변수와 메소드를 클래스라는 캡슐에 넣는 것이다. 즉, 관련된 기능(메소드)과 속성(변수)을 한 곳에 모으고 분류하기 때문에 재활용이 원활하다.
        목적 : 코드를 수정 없이 재활용하는 것
        또한, 캡슐화를 통해 정보 은닉이 가능하다.
        
        상속
        부모 클래스의 속성과 기능을 그대로 이어 받아 사용할 수 있게 하고 기능의 일부분을 변경해야 할 경우, 상속 받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.
        
        상속을 통해서 클래스를 작성하면 보다 적은 양의코드로 새로운 클래스를 작성할 수 있다.
        또한, 코드를 공통적으로 관리하여 코드 추가 및 변경이 용이하다.
        
        상속의 단점
        상위 클래스 기능에 버그가 생기거나 기능의 추가/변경 등으로 변화가 생겼을 때 상위 클래스를 상속 받는 하위 클래스가 정상적으로 작동할 수 있을지에 대한 예측이 힘듬
        
        상위 클래스에서 의미 있었던 기능이 하위 클래스에서는 의미 없는 기능일 수 있음
        
        다형성
        하나의 변수명, 함수명 등이 상황에 따라서 다른 의미로 해석될 수 있는 것이다.
        즉, 오버라이딩, 오버로딩이 가능하다
        
    
    제네릭이 뭔가요?
    
    - 
        
        제네릭(Generic)은 다양한 타입의 객체를 다룰 수 있도록 하고, 컴파일 시에 타입 검사를 수행하여 타입 안정성을 제공하는 기능입니다. 
        
        제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다
        
        **1. 제네릭의 이점:**
        
        - **타입 안정성(Type Safety)**: 제네릭은 컴파일 시에 타입 검사를 수행하기 때문에 타입 안정성을 보장합니다. 잘못된 타입 사용으로 인한 런타임 오류를 사전에 방지할 수 있습니다.
        - **코드 재사용성(Reusability)**: 제네릭을 사용하면 동일한 로직을 다양한 타입에 대해 재사용할 수 있습니다. 타입에 의존하지 않는 일반적인 알고리즘을 작성할 수 있습니다.
        - **컴파일 시간 타입 체크(Compile-Time Type Checking)**: 제네릭을 사용하면 컴파일 시에 타입 체크가 이루어지므로 잘못된 타입 사용으로 인한 오류를 빠르게 찾아낼 수 있습니다.
        
        **제네릭의 단점**
        
        1. **타입 지정의 복잡성**: 제네릭을 사용하면 코드가 더 복잡해질 수 있습니다. 타입 매개변수, 와일드카드, 제한된 타입 매개변수 등을 이해하고 사용해야 하며, 타입 관련 오류를 해결하기 위해 추가적인 처리가 필요할 수 있습니다.
        2. **컴파일 시간 증가**: 제네릭은 컴파일 시에 타입 체크를 수행하기 때문에 일반적인 코드보다 컴파일 시간이 더 오래 걸릴 수 있습니다. 특히 제네릭 타입 매개변수가 많고 복잡한 경우에는 컴파일 시간이 늘어날 수 있습니다.
        3. **런타임 성능 저하**: 제네릭은 컴파일 시에 타입 체크를 하기 때문에 런타임에는 타입 정보가 제거됩니다. 이로 인해 제네릭을 사용하는 코드에서는 추가적인 타입 체크나 형변환을 수행해야 합니다. 이는 일부 경우에 성능 저하를 초래할 수 있습니다.
        4. **배열 생성 제한**: 제네릭 배열을 직접 생성하는 것은 허용되지 않습니다. 제네릭 배열을 생성하려고 할 때는 경고가 발생하며, 배열 대신 컬렉션을 사용하는 것이 권장됩니다.
        5. **타입 소거(Type Erasure)**: 제네릭은 컴파일 시에만 타입 체크를 하고, 런타임에는 타입 정보를 소거합니다. 이로 인해 일부 타입 관련 정보가 손실되므로, 제네릭 타입의 실제 타입 인자를 런타임에 확인하는 것이 제한적입니다.
        
        제네릭을 사용하면 타입 안정성을 확보하면서 코드의 재사용성과 확장성을 높일 수 있습니다.
        
    
    Error와 Exception의 차이는 뭔가요?
    
    - 
        
        Error: 프로그램 코드로 수습할 수 없는 심각한 오류
        
        Exception: 프로그램 코드로 수습이 가능한 다소 미약한 오류
        
    
    RuntimeException과 일반 Exception에 대해 설명해보세요(checked vs unchecked)
    
    - 
        
        예외는 두 가지 유형으로 나눌 수 있습니다: RuntimeException과 일반 Exception입니다.
        
        **1. RuntimeException:**
        RuntimeException은 "Unchecked Exception"이라고도 불리며, 컴파일러가 체크하지 않는 예외입니다. RuntimeException은 프로그래머의 실수나 예기치 않은 상황에 의해 발생하는 예외를 나타냅니다. 대표적인 RuntimeException 클래스로는 NullPointerException, IllegalArgumentException, IndexOutOfBoundsException 등이 있습니다. RuntimeException은 예외 처리를 강제하지 않기 때문에 예외를 명시적으로 처리하지 않아도 컴파일이 가능합니다. 하지만 예외가 발생한 경우, 프로그램은 해당 예외를 처리하지 않고 중단될 수 있습니다.
        
        **2. 일반 Exception:**
        일반 Exception은 "Checked Exception"이라고도 불리며, 컴파일러가 체크하는 예외입니다. 일반 Exception은 주로 외부 요인에 의해 발생하는 예외를 나타냅니다. 파일 입출력 오류, 네트워크 연결 오류 등이 대표적인 예입니다. 일반 Exception은 예외 처리를 강제하므로, 예외를 명시적으로 처리하거나 throws 문을 사용하여 호출한 메서드로 예외를 전파해야 합니다. 이러한 예외 처리의 강제성은 프로그램 안정성과 예외 상황에 대한 적절한 대응을 도와줍니다.
        
        일반적으로 RuntimeException은 프로그래머의 실수나 예상치 못한 상황에 의한 예외를 나타내는 반면, 일반 Exception은 외부 요인에 의한 예외를 나타냅니다. RuntimeException은 예외 처리를 강제하지 않으므로 프로그래머가 명시적으로 예외를 처리할 필요가 없습니다. 반면에 일반 Exception은 예외 처리를 강제하므로 프로그래머가 예외를 적절히 처리해야 합니다.
        
    
    자바의 Synchronized에 대해 자세히 설명해보세요.
    
    - 
        
        자바의 **`synchronized`**는 여러 스레드 간의 동기화를 제공하는 키워드입니다. **`synchronized`**를 이용하여 특정 메서드 또는 블록을 동기화할 수 있습니다. 동기화는 한 스레드가 동일한 객체 또는 클래스의 **`synchronized`** 메서드 또는 블록에 진입할 때 다른 스레드가 해당 부분에 접근하지 못하도록 제어하는 메커니즘입니다.
        
        **장점:**
        
        1. **스레드 안전성 보장**: **`synchronized`**를 사용하면 여러 스레드 간에 데이터 무결성을 보장할 수 있습니다. 하나의 스레드가 **`synchronized`** 메서드 또는 블록에 진입하면 다른 스레드는 해당 부분에 접근할 수 없어서 동시에 데이터를 수정하거나 오용하는 문제를 방지할 수 있습니다.
        2. **코드 간결성**: **`synchronized`**를 사용하면 스레드 동기화에 필요한 코드를 직접 작성할 필요가 없어지므로 코드가 간결해집니다.
        
        **단점:**
        
        1. **성능 저하**: **`synchronized`**는 동기화된 코드 블록에 대해 상호 배제(lock)를 사용하므로, 여러 스레드가 동시에 접근하지 못하도록 막아야 합니다. 이로 인해 스레드가 대기하거나 경쟁하는 상황이 발생하면 성능이 저하될 수 있습니다.
        2. **데드락 가능성**: **`synchronized`**를 사용할 때 두 개 이상의 객체에 대해 동시에 접근하면 데드락(deadlock)이 발생할 수 있습니다. 데드락은 스레드가 서로가 가진 lock을 점유하고 대기하면서 상호배제를 해제하지 못하는 상태를 의미합니다.
        
        **유의할 점:**
        
        1. **`synchronized`**는 인스턴스 메서드, 정적 메서드, 블록 등에 적용할 수 있습니다.
        2. **`synchronized`**는 단일 객체 단위로 동기화되기 때문에 다른 객체에 대한 접근은 동기화되지 않습니다.
        3. 과도한 **`synchronized`** 사용은 성능 저하를 초래할 수 있으므로 필요한 부분에만 적절히 사용해야 합니다.
        4. **`synchronized`**를 사용하는 경우, 스레드 간에 lock을 얻고 해제하는 과정에서 발생하는 경합 상태에 유의해야 합니다.
        
        Java 5부터는 **`synchronized`** 대신 **`java.util.concurrent`** 패키지에서 제공하는 더 효율적인 동시성 관련 클래스와 인터페이스들을 사용하는 것이 권장됩니다. 예를 들어, **`ReentrantLock`**, **`Semaphore`**, **`CountDownLatch`** 등을 활용하여 보다 세밀한 제어가 가능합니다.
        
    
    Synchronized를 하면 왜 느려지나요?
    
    - 
        
        동기화(synchronization)는 여러 스레드가 공유된 자원에 동시에 접근하는 것을 제어하기 위해 사용됩니다. 동기화는 한 스레드가 임계 영역(critical section)에 진입할 때 다른 스레드들이 해당 영역에 접근하지 못하도록 막습니다.
        
        동기화가 걸려있는 코드의 내부 동작 과정은 다음과 같습니다:
        
        1. 스레드가 동기화된 메서드나 블록에 진입하려고 합니다.
        2. 스레드는 해당 동기화 영역에 대한 락(lock)을 획득하기 위해 시도합니다.
        3. 만약 락이 이미 다른 스레드에 의해 획득되었다면, 스레드는 대기 상태로 전환됩니다.
        4. 락이 획득되면 스레드는 동기화 영역의 코드를 실행합니다.
        5. 스레드가 동기화 영역을 빠져나오면, 해당 락을 해제합니다.
        
        동기화는 락(lock)을 사용하여 스레드 간의 상호 배제를 구현하는데, 이에는 일부 오버헤드가 발생할 수 있습니다. 동기화된 메서드나 블록에 진입하고 빠져나올 때마다 락을 획득하고 해제하는 과정이 추가되기 때문입니다. 
        
        이로 인해 스레드 간의 경합이 발생하고, 락이 이미 획득된 상태에서 다른 스레드가 접근하려고 할 경우 대기 상태로 전환됩니다. 이러한 대기 상태와 경합으로 인해 성능 저하가 발생할 수 있습니다.
        
        따라서 동기화는 필요한 경우에만 사용해야 합니다. 만약 여러 스레드가 동시에 접근하지 않는 자원이라면 동기화를 적용할 필요가 없습니다. 또한, 동기화 범위를 가능한 한 작게 가져가는 것이 성능 향상에 도움이 될 수 있습니다.
        
    
    volatile이 뭔가요? 어느 상황에서 쓰죠? 가시성이 뭔가요?
    
    - 
        
        **`volatile`**은 자바에서 사용되는 키워드로, 변수의 가시성과 순서화에 관련된 동작을 지정하는 데 사용됩니다.
        
        **`volatile`** 키워드가 선언된 변수는 다음과 같은 특징을 가집니다:
        
        1. 가시성 보장: **`volatile`** 변수는 여러 스레드에서 공유될 때 변수의 변경 사항이 다른 스레드에 즉시 반영되도록 보장합니다. 다른 스레드에서 **`volatile`** 변수를 읽을 때는 항상 최신 값을 읽게 됩니다.
        2. 원자적 연산: **`volatile`** 변수는 일부 원자적 연산(atomic operation)을 보장합니다. 즉, 변수의 값을 읽고 쓰는 동작이 원자적으로 수행되어 스레드 간의 경쟁 상태(race condition)가 발생하지 않도록 합니다.
        3. 순서화 방지: **`volatile`** 변수는 변수의 값을 읽고 쓰는 동작을 순서화하여 스레드 간의 실행 순서를 보장합니다. **`volatile`** 변수 앞 뒤의 코드가 변수에 대한 읽기 또는 쓰기 작업과 연관되어 있을 때, 이를 통해 코드의 순서를 제어할 수 있습니다.
        
        **`volatile`** 키워드는 주로 다음과 같은 상황에서 사용됩니다:
        
        1. 공유된 상태를 가지는 변수: 여러 스레드에서 공유하는 변수가 있을 때, **`volatile`** 키워드를 사용하여 변수의 가시성을 보장하고 스레드 간의 동기화를 수행할 수 있습니다.
        2. 상태 변경 플래그: 어떤 조건에 따라 상태를 변경하는 플래그 변수가 있을 때, **`volatile`** 키워드를 사용하여 플래그 변수의 변경 사항을 다른 스레드에 즉시 알릴 수 있습니다.
        
        **`volatile`** 변수의 가시성은 변수의 변경 사항이 즉시 다른 스레드에게 알려지고, 읽을 때는 항상 최신 값을 읽게 됨을 의미합니다. 이는 스레드 간의
        
    
    통합테스트와 단위테스트의 차이가 뭔가요?
    
    - 
        
        **단위 테스트(Unit Test):**
        
        - 단위 테스트는 소프트웨어의 가장 작은 단위인 모듈, 함수, 또는 클래스와 같은 개별적인 단위를 독립적으로 테스트하는 것입니다.
        - 단위 테스트는 해당 단위의 동작이 올바르게 작동하는지를 확인하고 개발자가 작성한 코드의 기능을 검증하는 데 중점을 둡니다.
        - 단위 테스트는 모의 객체(Mock object)나 가짜 객체(Fake object)를 사용하여 의존성을 격리시키고, 자동화된 방식으로 반복적으로 실행될 수 있도록 작성됩니다.
        - 단위 테스트는 개발 초기 단계부터 빠르게 테스트하며, 코드 변경 시에도 신속하게 실행하여 빠른 피드백을 제공합니다.
        - 대개 테스트 케이스 수는 많고, 단위 테스트 전체 실행 시간은 짧습니다.
        
        **통합 테스트(Integration Test):**
        
        - 통합 테스트는 여러 개의 모듈 또는 컴포넌트가 함께 작동할 때의 상호 작용을 테스트하는 것입니다.
        - 통합 테스트는 다양한 모듈 간의 상호 작용, 데이터 흐름, 인터페이스 일관성 등을 검증하고 시스템의 전반적인 동작을 확인하는 데 초점을 둡니다.
        - 통합 테스트는 실제 데이터베이스, 외부 시스템과의 통합, 네트워크 통신 등 실제 환경과 유사한 상황에서 테스트를 수행합니다.
        - 통합 테스트는 단위 테스트와는 달리 환경 설정과 초기화에 시간이 더 소요되고, 실행 시간도 더 오래 걸릴 수 있습니다.
        - 대개 테스트 케이스 수는 적고, 통합 테스트 전체 실행 시간은 상대적으로 길어질 수 있습니다.
        
        단위 테스트는 개별 단위의 기능 검증과 코드 품질 개선에 중점을 두는 반면, 통합 테스트는 다양한 모듈 간의 상호작용과 전체 시스템 동작의 일관성을 확인하는 데 중점을 둡니다. 두 테스트는 상호 보완적으로 사용되며, 소프트웨어의 신뢰성과 품질 향상에 기여합니다.
        
    
    List에 대해 설명해주세요
    
    - 
        
        List는 자바 컬렉션 프레임워크에서 제공되는 인터페이스로, 순서가 있는 데이터의 모음을 나타냅니다. List는 중복된 요소를 허용하며, 각 요소는 인덱스를 통해 접근할 수 있습니다.
        
        List 인터페이스는 다음과 같은 특징을 가지고 있습니다:
        
        1. 순서 유지: List는 요소의 순서를 유지합니다. 요소가 추가된 순서대로 저장되며, 인덱스를 통해 요소에 접근할 수 있습니다.
        2. 중복 요소: List는 중복된 요소를 허용합니다. 같은 값을 가진 요소를 여러 개 저장할 수 있습니다.
        3. 인덱스 기반 접근: List의 각 요소는 0부터 시작하는 인덱스를 가지고 있습니다. 따라서 인덱스를 통해 특정 위치의 요소에 접근하거나 수정할 수 있습니다.
        4. 크기 가변성: List는 크기가 가변적입니다. 요소의 추가, 삭제 등을 통해 크기가 동적으로 조절될 수 있습니다.
    
    Vector와 List의 차이를 설명해주세요.
    
    - 
        - 벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가집니다.
        - 벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않습니다. 검색적인 측면에서는 벡터가 우위에 있습니다.
        - 벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있습니다. 멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어집니다.
    
    LinkedList, DoubleLinkedList의 차이를 아는가?
    
    - 
        
        LinkedList:
        
        - LinkedList는 단일 연결 리스트로 구현됩니다. 각 요소는 다음 요소를 가리키는 단일 링크로 연결되어 있습니다.
        - 각 요소는 데이터와 다음 노드를 가리키는 링크를 가지고 있습니다.
        - 리스트의 처음과 마지막 요소를 가리키는 포인터(head와 tail)를 유지합니다.
        - 요소의 추가와 삭제가 비교적 빠르며, 특정 인덱스로의 접근은 선형적인 시간이 소요됩니다.
        - 단일 링크 구조로 인해 이전 요소로의 역방향 탐색은 지원하지 않습니다.
        
        DoublyLinkedList:
        
        - DoublyLinkedList는 이중 연결 리스트로 구현됩니다. 각 요소는 이전 요소와 다음 요소를 가리키는 두 개의 링크를 가지고 있습니다.
        - 각 요소는 데이터와 이전 노드를 가리키는 링크, 다음 노드를 가리키는 링크를 가지고 있습니다.
        - 리스트의 처음과 마지막 요소를 가리키는 포인터(head와 tail)를 유지합니다.
        - 요소의 추가와 삭제는 이전/다음 노드의 링크 조작이 필요하므로 연산이 상대적으로 더 복잡합니다.
        - 이전 요소로의 역방향 탐색이 가능하므로 양방향으로의 반복, 역순 접근 등의 작업에 용이합니다.
        
        DoublyLinkedList는 단일 연결 리스트에 비해 메모리 오버헤드가 크지만, 양방향으로의 탐색이 필요한 경우 효율적입니다. 또한 DoublyLinkedList는 요소의 추가와 삭제가 상대적으로 복잡하지만, 이전 요소로의 역방향 탐색이 필요한 상황에서 유리합니다. LinkedList와 DoublyLinkedList는 각각의 특징과 용도에 따라 선택하여 사용할 수 있습니다.
        
    
    ArrayList와 LinkedList의 차이는 무엇인가?
    
    - 
        
        ArrayList:
        
        - ArrayList는 내부적으로 동적 배열로 구현됩니다. 요소들은 연속된 메모리 공간에 저장됩니다.
        - 요소의 추가, 삭제 시에는 요소들을 이동시켜야 할 수도 있기 때문에 시간이 더 걸릴 수 있습니다.
        - 인덱스를 기반으로 한 빠른 접근과 검색이 가능합니다. 특정 인덱스에 접근하는 시간 복잡도는 O(1)입니다.
        - 크기를 동적으로 조절할 수 있습니다. 요소의 추가/삭제에 따라 크기가 자동으로 조절됩니다.
        - ArrayList는 데이터의 순차적인 접근에 유리하며, 읽기 작업이 많은 경우 성능이 좋습니다.
        
        LinkedList:
        
        - LinkedList는 내부적으로 이중 연결 리스트로 구현됩니다. 각 요소는 이전 요소와 다음 요소를 가리키는 링크로 연결됩니다.
        - 요소의 추가, 삭제 시에는 링크 조작만으로 이루어지므로 상대적으로 빠르게 처리됩니다.
        - 인덱스를 기반으로 한 접근은 선형적인 시간이 소요되기 때문에 느릴 수 있습니다. 특정 인덱스에 접근하는 시간 복잡도는 O(n)입니다.
        - 크기를 동적으로 조절할 수 있습니다. 요소의 추가/삭제에 따라 크기가 자동으로 조절됩니다.
        - LinkedList는 데이터의 삽입/삭제가 빈번한 경우에 유리하며, 요소의 순서 변경이 자주 발생하는 경우에도 성능이 좋습니다.
        
        ArrayList는 인덱스 기반의 빠른 접근이 중요한 경우에 사용될 수 있으며, LinkedList는 데이터의 동적인 추가/삭제가 빈번한 경우에 유용합니다. 
        
        또한 ArrayList는 메모리 상에서 연속된 공간을 사용하기 때문에 데이터의 캐싱 효율이 높을 수 있습니다. 반면 LinkedList는 각 요소의 링크 구조로 인해 추가적인 메모리 오버헤드가 발생할 수 있습니다. 
        
        따라서 데이터의 특성과 사용 패턴에 따라 ArrayList와 LinkedList 중 적절한 클래스를 선택하여 사용해야 합니다.
        
    
    Array와 List의 차이가 뭔가요?
    
    - 
        
        Array와 List는 둘 다 데이터를 저장하는 자료구조입니다. 하지만 두 가지 사소한 차이점이 있습니다.
        
        1. **크기의 가변성 (Size Flexibility):**
            - Array: Array는 크기가 고정되어 있으며, 배열이 생성될 때 지정한 크기를 유지합니다. 크기를 변경하려면 새로운 배열을 생성하고 기존 데이터를 복사해야 합니다.
            - List: List는 크기가 가변적입니다. 즉, 요소를 추가하거나 삭제할 때 크기가 자동으로 조정됩니다.
        2. **요소의 타입 체크 (Type Checking):**
            - Array: Array는 요소의 타입 체크가 엄격합니다. 배열을 생성할 때 지정한 타입과 호환되지 않는 요소를 추가하려고 하면 컴파일 오류가 발생합니다.
            - List: List는 제네릭을 사용하여 요소의 타입을 체크합니다. 따라서 List는 컴파일 시에 요소의 타입 안정성을 보장합니다.
        
        추가적으로, Java에서 List는 인터페이스로 정의되어 있으며, 여러 구현체가 존재합니다. 가장 일반적인 List 구현체로는 ArrayList, LinkedList, Vector 등이 있습니다. 
        
        이러한 List 구현체들은 내부적으로 Array를 사용하여 요소를 저장하고 관리합니다. 따라서 List는 Array의 일부 기능을 포함하면서 크기의 가변성과 타입 체크의 유연성을 제공합니다.
        
    
    List에서는 어떻게 크기를 동적으로 늘리나요?
    
    - 
        
        내부적으로 배열을 사용하여 요소를 저장합니다. ArrayList는 초기에는 일정한 용량(capacity)을 가진 배열을 생성하고, 요소를 추가하면 배열의 끝에 순차적으로 저장합니다
        
        **과정**
        
        1. 초기 용량: ArrayList는 초기에 일정한 용량을 가진 배열을 생성합니다. 보통은 초기 용량을 10 또는 더 큰 값으로 설정합니다. 초기 용량은 ArrayList의 생성자에 의해 지정할 수 있습니다.
        2. 요소 추가: ArrayList에 요소를 추가할 때, 현재 요소의 개수(size)와 배열의 용량(capacity)을 비교합니다. 만약 size가 capacity보다 크거나 같다면, 배열의 크기를 확장합니다.
        3. 배열 확장: 배열 확장은 기존 배열의 크기를 1.5배로 늘려서 새로운 배열을 생성합니다. 그리고 기존의 요소들을 새 배열로 복사합니다.
    
    Map 또는 Dictionary에 대해서 아는가?
    
    - 
        
        네, 맵(Map) 또는 딕셔너리(Dictionary)는 데이터를 키(Key)와 값(Value)의 쌍으로 저장하는 자료구조입니다. 키와 값은 일대일로 매핑되어 있으며, 키를 통해 해당 값에 접근하거나 값을 추가/삭제/수정할 수 있습니다.
        
        주요 특징:
        
        1. 유일한 키(Key): 맵은 중복된 키를 허용하지 않습니다. 각 키는 유일해야 합니다. 따라서, 동일한 키를 사용할 경우 새로운 값으로 대체됩니다.
        2. 키-값 쌍: 맵은 키와 값의 쌍으로 데이터를 저장합니다. 키는 값에 대한 식별자 역할을 하며, 값은 해당 키와 연관된 데이터를 의미합니다.
        3. 검색과 수정: 맵은 키를 사용하여 값을 검색하고 수정할 수 있습니다. 키를 통해 특정 값을 빠르게 찾을 수 있으므로 검색 속도가 빠릅니다.
        4. 다양한 구현체: 자바에서는 Map 인터페이스를 제공하며, HashMap, TreeMap, LinkedHashMap 등 다양한 구현체를 사용할 수 있습니다. 각 구현체는 내부적으로 데이터를 저장하고 검색하는 방식이 다르므로 특정 상황에 맞게 선택하여 사용할 수 있습니다.
        
        주요 용도:
        
        - 데이터 검색: 키를 사용하여 값을 검색하는 기능을 제공합니다. 맵은 빠른 검색 속도를 가지므로 대용량 데이터의 검색에 유용합니다.
        - 데이터 관리: 키-값 쌍으로 데이터를 저장하므로 데이터를 효율적으로 관리할 수 있습니다. 키를 기준으로 데이터를 추가, 수정, 삭제할 수 있습니다.
        - 데이터 구조화: 맵은 데이터를 구조화하여 키를 기준으로 접근하고 관리할 수 있습니다. 이를 통해 데이터를 논리적으로 그룹화하거나 연관성을 표현할 수 있습니다.
        
        맵은 다양한 프로그래밍 시나리오에서 유용하게 사용됩니다. 예를 들어, 데이터베이스의 테이블에서 특정 필드를 기준으로 검색하고 싶을 때, 맵을 사용하여 필드와 해당 레코드를 매핑할 수 있습니다. 또는 설정 파일에서 속성과 값을 매핑하여 설정 정보를 관리할 수도 있습니다.
        
    
    Hash와 Hash Function에 대해 설명해주세요
    
    - 
        
        해시(hash)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 매핑하는 것을 말합니다. 
        
        해시 함수(hash function)는 이러한 해시를 계산하는 함수입니다.
        
        - 데이터를 고정된 크기의 해시 코드로 변환하여 데이터를 고유하게 식별합니다.
        - 빠르게 해시 코드를 계산하여 데이터를 검색 및 비교하는 데 사용합니다.
        - 해시 함수는 입력 데이터의 작은 변화에도 다른 해시 코드를 생성하도록 설계되어 있어, 데이터의 무결성을 확인하는 데 사용될 수 있습니다.
        
        좋은 해시 함수는 다음과 같은 특성을 가집니다:
        
        - 동일한 입력에 대해서는 항상 동일한 해시 코드를 생성합니다.
        - 입력 데이터의 작은 변화에 대해 다른 해시 코드를 생성합니다. 이는 충돌(collision)을 최소화하는 역할을 합니다.
        - 해시 코드의 분포가 균일하게 이루어져야 합니다. 이는 해시 테이블에서 데이터를 균일하게 분산시키는 데 중요합니다.
        
        중요한 점은, 좋은 해시 함수의 선택과 충돌의 가능성을 최소화하는 것이 중요합니다. 충돌이 많이 발생하면 해시 테이블의 성능이 저하되고 검색 속도가 떨어질 수 있습니다
        
    
    HashMap vs HashTable은 무슨 차이가 있나요?
    
    - 
        1. 동기화 지원: HashTable은 동기화된 메소드로 구성되어 스레드 안전(thread-safe)한 동작을 보장합니다. 즉, 여러 스레드에서 동시에 접근하더라도 안전하게 사용할 수 있습니다. 반면, HashMap은 동기화를 지원하지 않으므로 멀티스레드 환경에서는 별도의 동기화 처리가 필요합니다.
        2. Null 허용: HashTable은 키(key)와 값(value)으로 null을 허용하지 않습니다. 즉, null을 저장하려고 하면 NullPointerException이 발생합니다. 하지만 HashMap은 키와 값 모두 null을 허용합니다.
        3. 성능: HashMap은 비동기 동작으로 설계되어 있어 단일 스레드 환경에서 빠른 성능을 제공합니다. 반면, HashTable은 동기화 메소드로 인해 스레드 경합이 발생할 수 있으므로 성능이 약간 저하될 수 있습니다.
        4. Iterator 동작: HashMap의 Iterator는 fail-fast 동작을 갖고 있습니다. 다시 말해, 컬렉션이 수정되면 Iterator가 ConcurrentModificationException을 던집니다. HashTable의 Iterator는 fail-safe 동작을 갖고 있어 컬렉션의 수정과 상관없이 안전하게 순회할 수 있습니다.
        5. Legacy 클래스: HashTable은 자바 초기 버전부터 제공되던 클래스로, 현재는 더 이상 권장되지 않습니다. HashMap은 자바 1.2부터 도입되었고, 보다 유연한 사용법과 더 나은 성능을 제공합니다.
        
        따라서, 일반적으로 단일 스레드 환경에서는 HashMap을 사용하는 것이 성능상 이점이 있고, 멀티스레드 환경에서는 동기화가 필요한 경우 HashTable을 사용할 수 있습니다. 
        
        그러나 현대적인 자바 애플리케이션에서는 ConcurrentHashMap과 같은 동시성을 지원하는 맵 자료구조를 선호하므로, HashTable보다는 HashMap이 더 일반적으로 사용됩니다.
        
    
    "HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?
    
    - 
        
        "HashMap"의 검색 속도가 빠른 이유는 해시 테이블의 인덱스를 바로 접근하여 값을 찾을 수 있기 때문입니다. 일반적으로 검색 시간은 O(1)에 가깝습니다. 하지만 최악의 경우 모든 키가 같은 인덱스에 해시 충돌이 발생하는 경우 검색 시간이 O(n)이 될 수 있습니다.
        
        Java 8 이상에서는 "HashMap"은 해시 충돌이 발생하는 경우에도 이진 탐색 트리(Red-Black Tree)로 변환하여 저장합니다. 이는 해시 충돌이 많이 발생하거나 연결 리스트의 길이가 길어지는 경우 성능을 향상시키기 위한 최적화입니다. 이진 탐색 트리는 O(log n)의 검색 시간을 제공하여 검색 속도를 개선합니다.
        
        따라서, "HashMap"은 해시 테이블과 이진 탐색 트리를 조합하여 키-값 쌍을 효율적으로 저장하고 검색할 수 있는 자료구조로 구현되어 있습니다.
        
    
    좋은 HashFunction은 뭐고 해쉬 충돌은 뭔가, 어떻게 해결하나요?
    
    - 
        
        좋은 Hash 함수는 해시 충돌이 적게 발생하도록 설계된 함수입니다. 해시 충돌은 서로 다른 입력값에 대해 동일한 해시 코드가 생성되는 상황을 말합니다. 이는 해시 테이블이나 해시 맵과 같은 자료구조에서 문제를 일으킬 수 있습니다.
        
        해시 충돌은 해시 함수의 설계나 사용하는 해시 테이블의 크기와 같은 요소에 의해 발생할 수 있습니다. 일반적으로 충돌은 해시 함수의 출력 범위보다 입력의 개수가 많을 때 발생할 가능성이 높아집니다. 충돌이 발생하면 동일한 해시 코드를 갖는 다른 요소들을 해시 테이블에서 처리하기 위한 추가적인 작업이 필요합니다.
        
        해시 충돌을 해결하기 위해 사용되는 주요한 기법은 다음과 같습니다:
        
        1. 체이닝(Chaining): 체이닝은 해시 충돌이 발생한 경우, 같은 해시 코드를 갖는 요소들을 연결 리스트 등의 자료구조로 연결하는 방식입니다. 각 버킷에는 연결 리스트가 저장되며, 충돌이 발생하면 해당 버킷에 연결 리스트에 새로운 요소를 추가합니다.
        2. 개방 주소법(Open Addressing): 개방 주소법은 충돌이 발생했을 때 다른 빈 버킷을 찾아서 요소를 삽입하는 방식입니다. 선형 조사(linear probing), 이차 조사(quadratic probing), 이중 해시(double hashing) 등이 개방 주소법의 일종입니다.
        
        충돌을 최소화하기 위해 해시 함수의 성능을 개선하고 충돌을 효과적으로 처리하는 충돌 해결 기법을 선택하는 것이 중요합니다. 
        
        좋은 해시 함수는 입력의 분포를 균등하게 해시 코드로 매핑하여 충돌이 최소화되도록 해야 합니다. 또한 충돌 해결 기법을 효율적으로 사용하여 충돌이 발생할 때 성능 저하를 최소화해야 합니다.
        
        효과적인 해시 함수 및 충돌 해결 기법은 자료의 특성에 따라 다를 수 있습니다. 일반적으로는 자바에서 제공하는 해시 맵 구현인 HashMap이 충돌 해결을 위해 체이닝 기법을 사용하고 있습니다.
        
    
    Queue와 Stack에 대해 설명할 수 있는가?
    
    - 
        1. Queue(큐):
            - FIFO(First-In, First-Out) 원칙을 따르는 자료구조입니다. 즉, 가장 먼저 삽입된 데이터가 가장 먼저 제거됩니다.
            - 큐는 데이터를 한쪽 끝에서 추가하고 다른 한쪽 끝에서 제거합니다. 이를 "인큐(Enqueue)"와 "디큐(Dequeue)"라고 합니다.
            - 대표적인 예시로 줄서기(Queuing)가 있습니다. 가장 먼저 온 사람이 가장 먼저 서비스를 받게 됩니다.
            - 자바에서는 Queue 인터페이스를 제공하며, LinkedList, ArrayDeque 등의 구현체를 사용할 수 있습니다.
        2. Stack(스택):
            - LIFO(Last-In, First-Out) 원칙을 따르는 자료구조입니다. 가장 마지막에 삽입된 데이터가 가장 먼저 제거됩니다.
            - 스택은 데이터를 한쪽 끝에서 추가하고 동일한 쪽에서 제거합니다. 이를 "푸시(Push)"와 "팝(Pop)"이라고 합니다.
            - 대표적인 예시로 책을 쌓아 올리는 것이 있습니다. 가장 마지막에 올린 책이 가장 먼저 빠져나올 수 있습니다.
            - 자바에서는 Stack 클래스를 제공하며, 주로 ArrayList와 같은 동적 배열을 내부 구현으로 사용합니다.
        
        Queue는 데이터의 순서가 중요하고, 스택은 데이터의 순서가 중요하지 않을 때 사용됩니다. Queue는 대기열 관리, 작업 처리, BFS(Breadth-First Search) 등에 주로 사용되며, 스택은 재귀 알고리즘, 괄호 매칭, DFS(Depth-First Search) 등에 주로 사용됩니다.
        
    
    List와 Set의 차이는 무엇인가?
    
    - 
        1. 저장 순서: List는 저장된 순서를 유지합니다. 즉, 요소가 추가된 순서대로 인덱스로 접근할 수 있습니다. Set은 저장 순서를 보장하지 않습니다. 따라서, 요소의 순서에 관계없이 고유한 요소들로 구성됩니다.
        2. 중복 허용 여부: List는 중복된 요소를 허용합니다. 동일한 요소를 여러 번 추가할 수 있습니다. Set은 중복된 요소를 허용하지 않습니다. 각 요소는 유일해야 합니다.
        3. 인덱스 기반 접근: List는 인덱스를 사용하여 요소에 접근할 수 있습니다. 인덱스를 통해 요소를 검색, 변경, 삭제할 수 있습니다. Set은 인덱스를 제공하지 않습니다. 따라서, Set에서는 요소를 검색하거나 변경하기 위해서는 다른 방식을 사용해야 합니다.
        4. 성능: List는 순차적인 데이터 액세스에 더 적합합니다. 인덱스를 사용하여 요소에 접근하기 때문에 특정 위치의 요소에 빠르게 접근할 수 있습니다. Set은 중복된 요소를 허용하지 않기 때문에 내부적으로 중복을 확인하는 추가적인 작업이 필요합니다. 따라서, List보다는 Set이 약간의 성능 저하가 있을 수 있습니다.
        5. 구현 클래스: List의 대표적인 구현 클래스로는 ArrayList, LinkedList 등이 있습니다. Set의 대표적인 구현 클래스로는 HashSet, TreeSet 등이 있습니다. 각 구현 클래스는 내부 동작 방식과 특징에 차이가 있으며, 사용 시 해당 클래스의 특성을 고려해야 합니다.
        
        주로 데이터의 순서와 중복 여부에 따라 List와 Set 중에서 선택합니다. List는 데이터를 순차적으로 관리하고, 중복된 값이 필요한 경우에 사용됩니다. Set은 고유한 요소를 유지하고, 순서가 중요하지 않거나 중복된 요소를 허용하지 않아야 하는 경우에 사용됩니다.
        
    
    Tree란 무엇입니까?
    
    - 
        
        트리(Tree)는 계층적인 구조를 가지며, 여러 개의 노드(Node)로 구성된 비선형 자료구조입니다. 트리는 부모-자식 관계로 이루어진 계층 구조를 표현하는데 사용됩니다.
        
        트리의 기본 구성 요소는 다음과 같습니다:
        
        1. 노드(Node): 트리의 기본 요소로서 데이터와 연결된 객체입니다. 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다. 노드는 데이터를 저장하는데 사용되며, 추가적인 속성과 연결 정보를 가질 수도 있습니다.
        2. 루트(Root): 트리의 최상위 노드로, 다른 모든 노드는 루트로부터 직간접적으로 연결됩니다. 트리는 오직 하나의 루트 노드를 가집니다.
        3. 부모(Parent)와 자식(Child): 트리의 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다. 부모 노드는 자식 노드를 가리키는 링크(연결)를 가지고 있으며, 자식 노드는 부모 노드를 참조하는 링크를 가지고 있습니다.
        4. 리프(Leaf): 자식이 없는 노드를 리프 노드라고 합니다. 즉, 리프 노드는 트리의 가장 하위 단계에 위치한 노드입니다.
        
        트리는 다양한 종류와 변형이 있으며, 각각의 종류에 따라 특정한 특성과 용도를 가집니다. 일반적으로 사용되는 트리 종류에는 이진 트리(Binary Tree), 이진 탐색 트리(Binary Search Tree), AVL 트리, B 트리(B-Tree), 힙(Heap), 트라이(Trie) 등이 있습니다. 
        
        각각의 트리 종류는 특정한 성질이나 제약조건을 가지고 있으며, 데이터를 효율적으로 저장, 검색, 정렬하는데 사용됩니다.
        
        트리는 데이터 구조, 알고리즘, 데이터베이스, 운영체제 등 다양한 분야에서 활용되며, 효율적인 데이터 조작과 검색을 위해 중요한 역할을 합니다.
        
        **이진 검색의 예시를 들어줄수있나요?**
        
        이진 검색(Binary Search)은 정렬된 배열 또는 리스트에서 특정한 값을 찾는 알고리즘입니다. 이진 검색은 배열의 중간 값을 선택하여 찾고자 하는 값과 비교하며, 찾고자 하는 값이 중간 값보다 작으면 배열의 왼쪽 절반을 대상으로, 크면 오른쪽 절반을 대상으로 검색을 수행합니다.
        
        1. 배열 [1, 4, 8, 12, 18, 25, 30]에서 숫자 18을 찾는 경우:
            - 중간 값인 12와 18을 비교합니다. 12는 18보다 작으므로 오른쪽 절반인 [18, 25, 30]을 대상으로 검색을 수행합니다.
            - 새로운 중간 값인 25와 18을 비교합니다. 25는 18보다 크므로 왼쪽 절반인 [18]을 대상으로 검색을 수행합니다.
            - 배열의 크기가 1이 되었고, 해당 값이 18이므로 검색을 종료합니다.
        2. 배열 [2, 5, 7, 9, 11, 15]에서 숫자 8을 찾는 경우:
            - 중간 값인 7과 8을 비교합니다. 7은 8보다 작으므로 오른쪽 절반인 [9, 11, 15]을 대상으로 검색을 수행합니다.
            - 새로운 중간 값인 11과 8을 비교합니다. 11은 8보다 크므로 왼쪽 절반인 [9]을 대상으로 검색을 수행합니다.
            - 배열의 크기가 1이 되었고, 해당 값이 존재하지 않으므로 검색을 종료합니다.
        
        이진 검색은 배열이 정렬되어 있어야만 사용할 수 있으며, 탐색 속도가 빠르기 때문에 크기가 큰 배열에서 효과적으로 사용됩니다.
        
    
    HashSet, TreeSet, LinkedHashSet의 차이
    
    - 
        
        TreeSet과 LinkedHashSet은 모두 Set 인터페이스를 구현한 구현 클래스로서, 다음과 같은 차이점을 가지고 있습니다:
        
        1. 내부 구조: TreeSet은 이진 검색 트리로 구현되어 있습니다. 따라서, 요소들이 정렬된 상태로 저장되고, 검색과 정렬된 순서로 순회할 수 있습니다. LinkedHashSet은 해시 테이블과 연결 리스트를 결합한 방식으로 구현되어 있습니다. 요소들이 해시 테이블에 저장되며, 추가된 순서를 유지하면서 순회할 수 있습니다.
        2. 정렬 및 순회: TreeSet은 요소들이 자동으로 정렬되어 저장되기 때문에, 요소들을 정렬된 순서로 순회할 수 있습니다. 이진 검색 트리의 특성을 이용하여 범위 기반 검색이나 정렬된 집합 연산도 효율적으로 수행할 수 있습니다. LinkedHashSet은 요소들이 추가된 순서를 유지하기 때문에, 순회 시 추가된 순서대로 접근할 수 있습니다.
        3. 성능: TreeSet의 검색, 삽입, 삭제 등의 연산은 이진 검색 트리의 특성을 이용하여 평균적으로 O(log n)의 시간 복잡도를 가집니다. LinkedHashSet은 해시 테이블의 해시 함수를 이용하므로, 검색, 삽입, 삭제 연산은 보통 O(1)의 상수 시간 복잡도를 가지지만 해시 충돌이 발생할 경우 성능이 저하될 수 있습니다.
        
        다른 비교 기반 Set 구현 클래스로는 HashSet이 있습니다. HashSet은 해시 테이블을 기반으로 요소를 저장하며, 순서를 보장하지 않습니다. HashSet은 검색, 삽입, 삭제 연산이 평균적으로 O(1)의 시간 복잡도를 가지지만, 순회 순서는 예측할 수 없습니다.
        
        각각의 Set 구현 클래스는 다른 특징과 성능을 가지고 있으므로, 사용하는 상황과 요구사항에 따라 적절한 구현 클래스를 선택해야 합니다.
        
    
    디자인패턴을 사용하는 이유가 뭔가요?
    
    - 
        
        디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제들을 해결하기 위해 사용되는 일련의 설계 원칙과 모범 사례들의 집합입니다. 디자인 패턴은 다음과 같은 이유로 사용됩니다:
        
        1. 재사용성: 디자인 패턴은 검증된 솔루션들을 제공하므로, 비슷한 문제에 대해 반복적으로 해결할 필요 없이 패턴을 재사용하여 개발 시간을 단축시킬 수 있습니다.
        2. 확장성: 디자인 패턴은 유연하고 확장 가능한 설계를 촉진합니다. 각 패턴은 모듈화되어 있어서 시스템의 특정 부분만 변경하거나 추가하여 전체 시스템을 확장할 수 있습니다.
        3. 유지보수성: 디자인 패턴은 코드의 가독성과 이해도를 높이며, 변경 사항에 대한 영향을 최소화합니다. 패턴을 사용하면 코드가 잘 구조화되어 있어서 유지보수와 디버깅이 쉬워집니다.
        4. 코드 품질 향상: 디자인 패턴은 설계 원칙과 모범 사례를 제공하므로, 좋은 코드 품질을 유지할 수 있습니다. 패턴을 따르면 일관성 있는 코드 작성이 가능해지고, 읽기 쉽고 이해하기 쉬운 코드를 작성할 수 있습니다.
        5. 설계의 명확화: 디자인 패턴은 개발자들 사이의 의사소통을 원활하게 합니다. 패턴은 공통된 언어와 구조를 제공하므로, 팀원들 간에 설계 결정에 대한 이해도를 높일 수 있습니다.
        6. 소프트웨어 아키텍처 개선: 디자인 패턴은 소프트웨어 아키텍처를 개선하는 데 도움을 줍니다. 패턴은 모듈화, 계층화, 분산 시스템 등 다양한 아키텍처 스타일을 지원하며, 확장성과 유연성을 강조하는 구조를 구현할 수 있습니다.
        
        이러한 이유로 디자인 패턴은 소프트웨어 개발에서 품질과 생산성을 향상시키는 데 중요한 역할을 합니다. 개발자들은 다양한 패턴을 익히고 적절한 상황에서 적용하여 좀 더 견고하고 유지보수 가능한 소프트웨어를 개발할 수 있습니다.
        
    
    싱글턴 패턴에 대해 설명해주세요
    
    - 
        
        싱글턴 패턴은 디자인 패턴 중 하나로, 어떤 클래스의 인스턴스를 전역적으로 하나만 생성하고, 이를 여러 곳에서 공유하여 사용하는 방식을 말합니다. 주로 시스템 내에서 단 하나의 객체만 필요한 경우에 사용됩니다.
        
        싱글턴 패턴을 구현하기 위해서는 다음과 같은 특징을 갖는 클래스를 정의해야 합니다:
        
        1. 프라이빗 생성자 (Private Constructor): 외부에서 인스턴스를 직접 생성하는 것을 막기 위해 생성자를 private으로 선언합니다.
        2. 정적 메소드 (Static Method): 유일한 인스턴스에 접근할 수 있는 정적 메소드를 제공합니다. 이 메소드는 항상 동일한 인스턴스를 반환하도록 구현되어야 합니다.
        3. 정적 변수 (Static Variable): 유일한 인스턴스를 저장하기 위한 정적 변수를 선언합니다. 이 변수는 private으로 선언되어 외부에서 직접 접근할 수 없도록 합니다.
        
        싱글턴 패턴은 다음과 같은 장점을 갖습니다:
        
        1. 유일한 인스턴스 보장: 싱글턴 패턴을 사용하면 어떤 클래스의 인스턴스가 전역적으로 하나만 생성되므로, 동일한 객체를 여러 곳에서 공유하여 사용할 수 있습니다.
        2. 전역적인 접근성: 싱글턴 패턴을 사용하면 어디서든 동일한 인스턴스에 접근할 수 있습니다. 이는 객체 간의 데이터 공유와 상태 유지에 유용합니다.
        3. 리소스 관리: 싱글턴 패턴을 사용하여 리소스를 관리할 때 효율적인 방법을 제공할 수 있습니다. 예를 들어 데이터베이스 연결, 파일 시스템 접근 등의 리소스를 단일 인스턴스에서 관리할 수 있습니다.
        
        싱글턴 패턴은 주의해야 할 점도 있습니다:
        
        1. 멀티스레딩 환경에서의 동기화: 멀티스레드 환경에서 동시에 싱글턴 인스턴스를 생성하려는 경우에 동기화 문제가 발생할 수 있습니다. 이를 해결하기 위해서는 동기화 메커니즘을 사용하거나 초기화할 때 인스턴스를 생성하는 Lazy Initialization 방식을 선택할 수 있습니다.
        2. 테스트와 모의 객체(Mock Object): 싱글턴 인스턴스에 의존하는 코드는 테스트와 모의 객체(Mock Object) 생성에 어려움을 겪을 수 있습니다. 의존성 주입(Dependency Injection)을 활용하여 이 문제를 해결할 수 있습니다.
        
        싱글턴 패턴은 유용한 디자인 패턴 중 하나이지만, 남용할 경우 전역 상태와 결합도가 높은 코드를 만들 수 있으므로 신중하게 사용해야 합니다.
        
    
    싱글턴이 안티패턴이라고 불리는 이유는 뭔가요?
    
    - 
        1. 글로벌 상태와 결합도: 싱글턴 패턴을 사용하면 객체 간의 결합도가 높아지고, 글로벌 상태를 유지하는데 사용되기 때문입니다. 이는 유지보수와 테스트에 어려움을 줄 수 있습니다.
        2. 멀티스레딩 문제: 멀티스레드 환경에서 싱글턴 패턴을 사용할 때 동기화 문제가 발생할 수 있습니다. 동기화 처리를 하지 않으면 여러 스레드에서 동시에 인스턴스를 생성할 수 있으며, 동기화 처리를 하면 성능 저하가 발생할 수 있습니다.
        3. 테스트와 모의 객체 생성의 어려움: 싱글턴 패턴을 사용한 클래스는 테스트하기 어려울 수 있습니다. 테스트 시에 싱글턴 인스턴스에 의존하는 코드를 테스트하기 위해 모의 객체(Mock Object)를 사용하기가 어렵습니다.
    
    스프링의 싱글턴과는 어떤 차이가 있나요?
    
    - 
        
        스프링에서 사용하는 싱글턴 패턴은 일반적인 싱글턴 패턴과 다릅니다. 스프링은 객체의 생성과 관리를 컨테이너에 위임하여 싱글턴 객체를 생성하고 제공합니다. 스프링 컨테이너는 싱글턴 빈으로 등록된 객체를 생성하고 필요한 곳에 주입합니다.
        
        자바 버전
        
        ```java
        public class Singleton {
            private static Singleton instance;
            
            private Singleton() {
                // private 생성자
            }
            
            public static Singleton getInstance() {
                if (instance == null) {
                    instance = new Singleton();
                }
                return instance;
            }
        }
        ```
        
        위의 예시는 lazy initialization 방식의 싱글턴 패턴으로, 인스턴스를 처음 사용하는 시점에서 생성됩니다. 하지만 멀티스레드 환경에서 동시에 getInstance() 메소드가 호출되면 인스턴스가 중복 생성될 수 있습니다.
        
        스프링 버전
        
        ```java
        @Service
        public class MyService {
            // 클래스에 @Service 애너테이션을 추가하여 스프링 빈으로 등록됨
            // 스프링 컨테이너가 싱글턴 객체의 생성과 관리를 담당
            
            // 필요한 의존성 주입
            @Autowired
            private MyDependency myDependency;
            
            // 싱글턴 객체의 메소드
            public void doSomething() {
                // 싱글턴 객체의 로직
            }
        }
        ```
        
        위의 예시에서 **`MyService`** 클래스는 **`@Service`** 애너테이션을 통해 스프링 빈으로 등록됩니다. 스프링 컨테이너는 **`MyService`**의 인스턴스를 생성하고 필요한 의존성을 주입하여 관리합니다. 다른 곳에서 **`MyService`**를 필요로 할 때 스프링 컨테이너에서 해당 싱글턴 인스턴스를 제공하게 됩니다. 이를 통해 스프링은 싱글턴 객체의 생성과 관리를 효과적으로 처리합니다.
        
    
    전략패턴과, 템플이트 패턴에 대해 코드와 함께 설명해보세요
    
    - 
        
        전략 패턴과 템플릿 패턴은 둘 다 객체지향 디자인 패턴 중에서 알고리즘을 캡슐화하고 재사용성을 높이는 목적을 가지고 있지만, 차이점이 있습니다.
        
        1. 목적:
            - 전략 패턴: 알고리즘의 동적인 변경과 확장을 지원하기 위해 사용됩니다. 여러 알고리즘 중에서 실행시간에 원하는 알고리즘을 선택할 수 있습니다.
            - 템플릿 패턴: 알고리즘의 일부분을 서브클래스에 위임하여 재사용성을 높이고, 일관성 있는 알고리즘 실행 순서를 제공하기 위해 사용됩니다.
        2. 구성 요소:
            - 전략 패턴: 전략 인터페이스와 이를 구현한 여러 전략 클래스로 구성됩니다. 클라이언트는 전략을 동적으로 교체할 수 있습니다.
            - 템플릿 패턴: 추상 클래스 또는 인터페이스와 이를 구현한 여러 서브클래스로 구성됩니다. 추상 클래스에는 일련의 알고리즘 단계가 정의되어 있으며, 서브클래스에서는 이러한 단계를 구현합니다.
        3. 확장성:
            - 전략 패턴: 새로운 전략 클래스를 추가하여 알고리즘을 확장할 수 있습니다. 기존 코드 변경 없이 새로운 전략을 추가할 수 있어 유연성이 높습니다.
            - 템플릿 패턴: 알고리즘의 일부분을 서브클래스에 위임하므로, 알고리즘의 구조 자체를 확장하기는 어렵습니다. 서브클래스에서 구현해야 하는 알고리즘 단계의 수를 변경할 수는 있지만, 새로운 알고리즘 단계를 추가하기는 어렵습니다.
        4. 실행 시점:
            - 전략 패턴: 실행 시간에 전략을 선택하고 교체할 수 있습니다.
            - 템플릿 패턴: 알고리즘의 구조가 정적으로 정의되어 있으며, 실행 시점에 변경될 수 없습니다.
        
        따라서, 전략 패턴은 동적인 알고리즘 변경과 확장을 지원하는 반면, 템플릿 패턴은 알고리즘의 구조와 일관된 실행 순서를 제공하며 재사용성을 높입니다.
        
        전략 패턴(Strategy Pattern)은 동적으로 알고리즘을 교체할 수 있는 유연한 설계 패턴입니다. 아래는 전략 패턴을 사용한 예제 코드입니다.
        
        ```java
        javaCopy code
        // 전략 인터페이스
        interface SortingStrategy {
            void sort(int[] array);
        }
        
        // 전략 구현 클래스
        class BubbleSortStrategy implements SortingStrategy {
            @Override
            public void sort(int[] array) {
                // 버블 정렬 알고리즘 구현
                // ...
            }
        }
        
        class QuickSortStrategy implements SortingStrategy {
            @Override
            public void sort(int[] array) {
                // 퀵 정렬 알고리즘 구현
                // ...
            }
        }
        
        // 전략 사용자 클래스
        class SortManager {
            private SortingStrategy sortingStrategy;
        
            public void setSortingStrategy(SortingStrategy sortingStrategy) {
                this.sortingStrategy = sortingStrategy;
            }
        
            public void performSort(int[] array) {
                sortingStrategy.sort(array);
            }
        }
        
        // 사용 예시
        public class Main {
            public static void main(String[] args) {
                int[] array = {5, 2, 8, 1, 9};
        
                SortManager sortManager = new SortManager();
                sortManager.setSortingStrategy(new BubbleSortStrategy());
                sortManager.performSort(array);
        
                // 혹은 다른 전략으로 교체할 수 있습니다.
                sortManager.setSortingStrategy(new QuickSortStrategy());
                sortManager.performSort(array);
            }
        }
        
        ```
        
        위의 예제 코드에서 **`SortingStrategy`**는 전략 인터페이스를 정의하고, **`BubbleSortStrategy`**와 **`QuickSortStrategy`**는 이를 구현합니다. **`SortManager`**는 사용자 클래스로서 전략을 동적으로 설정하고, **`performSort`** 메서드를 호출하여 정렬 작업을 수행합니다.
        
        템플릿 패턴(Template Pattern)은 알고리즘의 일부분을 서브클래스에 위임하여 코드 재사용성을 높이는 패턴입니다. 아래는 템플릿 패턴을 사용한 예제 코드입니다.
        
        ```
        javaCopy code
        // 템플릿 클래스
        abstract class Game {
            abstract void initialize();
            abstract void startPlay();
            abstract void endPlay();
        
            // 템플릿 메서드
            public final void play() {
                initialize();
                startPlay();
                endPlay();
            }
        }
        
        // 템플릿 구현 클래스
        class Football extends Game {
            @Override
            void initialize() {
                System.out.println("Football Game Initialized! Start playing.");
            }
        
            @Override
            void startPlay() {
                System.out.println("Football Game Started. Enjoy the game!");
            }
        
            @Override
            void endPlay() {
                System.out.println("Football Game Finished!");
            }
        }
        
        class Basketball extends Game {
            @Override
            void initialize() {
                System.out.println("Basketball Game Initialized! Start playing.");
            }
        
            @Override
            void startPlay() {
                System.out.println("Basketball Game Started. Enjoy the game!");
            }
        
            @Override
            void endPlay() {
                System.out.println("Basketball Game Finished!");
            }
        }
        
        // 사용 예시
        public class Main {
            public static void main(String[] args) {
                Game footballGame = new Football();
                footballGame.play();
        
                Game basketballGame = new Basketball();
                basketballGame.play();
            }
        }
        
        ```
        
        위의 예제 코드에서 **`Game`**은 템플릿 클래스로서 **`initialize()`**, **`startPlay()`**, **`endPlay()`** 메서드를 정의합니다. 이 메서드들은 일련의 알고리즘 단계를 정의하며, **`play()`** 메서드는 이러한 단계들을 순서대로 호출하는 템플릿 메서드입니다. **`Football`**과 **`Basketball`**은 템플릿 클래스를 상속받아 각각의 알고리즘 단계를 구현합니다. **`play()`** 메서드는 템플릿 클래스에서 정의된 알고리즘을 호출하여 게임을 진행합니다.
        
        템플릿 패턴을 사용하면 알고리즘의 일부분을 공통적으로 사용하면서도 다른 부분은 서브클래스에서 구현할 수 있어 코드의 중복을 줄이고 재사용성을 높일 수 있습니다.
        
    
    서블릿이 뭔가요?
    
    - 
        
        서블릿(Servlet)은 자바를 사용하여 웹 애플리케이션을 개발하기 위한 기술적인 사양이며, 웹 서버에서 동작하는 작은 프로그램이라고 할 수 있습니다. 서블릿은 클라이언트의 요청에 응답하는 역할을 수행하며, 동적인 웹 콘텐츠를 생성하고 처리하기 위해 사용됩니다.
        
        서블릿은 자바 언어를 기반으로 작성되며, 서블릿 컨테이너(예: Apache Tomcat, Jetty)에서 실행됩니다. 서블릿 컨테이너는 클라이언트의 요청을 받아 서블릿을 인스턴스화하고 실행하는 역할을 담당합니다.
        
        서블릿은 주로 웹 애플리케이션의 비즈니스 로직을 처리하고, HTTP 프로토콜을 통해 클라이언트와 통신합니다. 클라이언트의 요청을 받아 처리하고 그에 대한 응답을 생성하여 반환합니다. 서블릿은 HTTP 요청 메서드(GET, POST, PUT, DELETE 등)에 따라 적절한 동작을 수행하고, 요청 파라미터를 읽고 쓰며, 세션과 쿠키를 관리할 수 있습니다.
        
        서블릿은 다른 서블릿이나 JSP(JavaServer Pages)와 함께 사용되어 웹 애플리케이션의 동적인 기능을 개발하고 제공합니다. 서블릿은 자바의 객체지향적 특성을 활용하여 유지보수 가능하고 확장성이 좋은 웹 애플리케이션을 개발할 수 있도록 도와줍니다.
        
    
    프로세스 스레드 스레드풀 차이가 뭔가요?
    
    - 
        
        프로세스(Process)는 실행 중인 프로그램을 말하며, 운영체제로부터 자원을 할당받아 독립적으로 실행되는 작업 단위입니다. 각각의 프로세스는 독립적인 메모리 공간을 가지며, 다른 프로세스와는 메모리를 공유하지 않습니다. 프로세스는 운영체제에 의해 스케줄링되며, 각각의 프로세스는 최소한 하나의 스레드를 가지고 있습니다.
        
        스레드(Thread)는 프로세스 내에서 실행되는 단위로, 프로세스의 자원을 공유하여 작업을 수행합니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이러한 스레드들은 동시에 실행될 수 있습니다. 스레드는 프로세스의 메모리를 공유하므로 데이터를 공유하고 효율적인 작업을 수행할 수 있습니다. 스레드는 프로세스 내에서 병렬적으로 동작하며, 각각의 스레드는 독립적인 실행 경로를 가지고 있습니다.
        
        스레드풀(Thread Pool)은 스레드를 관리하는 기술로, 미리 생성된 스레드들을 풀에 보관해두고 작업이 필요할 때 해당 스레드를 가져와 작업을 처리하는 방식입니다. 스레드풀은 스레드 생성 및 제거의 오버헤드를 줄이고, 스레드의 재사용성을 높여 성능을 개선하는데 도움을 줍니다. 스레드풀은 일반적으로 한정된 개수의 스레드를 가지고 있으며, 작업 큐를 통해 순차적으로 작업을 처리합니다.
        
        요약하면, 프로세스는 실행 중인 프로그램을 나타내는 독립적인 작업 단위이고, 스레드는 프로세스 내에서 실행되는 작업 단위입니다. 스레드풀은 스레드를 효율적으로 관리하여 작업을 처리하는 기술입니다. 스레드풀을 사용하면 스레드의 생성과 제거에 따른 오버헤드를 줄이고, 동시에 여러 작업을 처리할 수 있는 성능을 개선할 수 있습니다.
        
    
    스레드로컬에 대해 자세히 설명해보세요
    
    - 
        
        스레드로컬(ThreadLocal)은 자바에서 멀티스레드 환경에서 스레드 간 데이터 공유를 위한 기술입니다. 스레드로컬을 사용하면 각 스레드마다 독립적인 변수를 사용할 수 있으며, 스레드 간의 데이터 충돌 문제를 피할 수 있습니다.
        
        ThreadLocal의 내부는 thread 정보를 key로 하여 값을 저장해두는 Map 구조를 가지고 있습니다.
        
        기본적인 사용에는 get, set 메서드를 이용합니다.
        
        스레드로컬은 스레드 내부에 데이터를 저장하는 맵 형태의 구조를 가지고 있습니다. 각 스레드는 자신만의 스레드로컬 인스턴스를 가지며, 이 인스턴스를 통해 데이터에 접근하고 수정할 수 있습니다. 다른 스레드는 동일한 스레드로컬 인스턴스를 사용하더라도 각각의 스레드마다 별도의 데이터를 가질 수 있습니다.
        
        스레드로컬은 일반적으로 전역 변수를 사용해야 하는 상황에서 스레드 간의 데이터 분리가 필요한 경우에 유용합니다. 예를 들어, 웹 애플리케이션에서 현재 요청을 처리하는 스레드의 식별자나 사용자 정보 등을 스레드로컬을 통해 저장하고 다른 클래스나 메서드에서 해당 데이터에 접근할 수 있습니다.
        
        스레드로컬의 활용은 다음과 같은 장점을 가집니다:
        
        1. 스레드 간의 데이터 공유를 피할 수 있습니다.
        2. 전역 변수를 사용하지 않고 스레드별로 데이터를 관리할 수 있습니다.
        3. 스레드 안전성을 보장합니다.
        
        스레드로컬의 사용에는 몇 가지 주의할 점이 있습니다:
        
        1. 스레드로컬은 데이터의 생명 주기를 스레드의 생명 주기에 맞추기 때문에 적절한 시점에서 값을 제거해야 합니다. 그렇지 않으면 메모리 누수가 발생할 수 있습니다.
        2. 스레드로컬을 오용하면 코드의 가독성을 해치고 디버깅이 어려워질 수 있으므로 신중하게 사용해야 합니다.
        
        아래는 자바에서 스레드로컬을 사용하는 간단한 예시 코드입니다:
        
        ```
        javaCopy code
        public class MyThreadLocalData {
            private static ThreadLocal<String> threadLocal = new ThreadLocal<>();
        
            public static void setThreadData(String data) {
                threadLocal.set(data);
            }
        
            public static String getThreadData() {
                return threadLocal.get();
            }
        
            public static void clearThreadData() {
                threadLocal.remove();
            }
        }
        
        // 스레드에서 데이터 설정
        MyThreadLocalData.setThreadData("Hello, Thread!");
        
        // 다른 클래스에서 스레드 데이터 사용
        String data = MyThreadLocalData.getThreadData();
        System.out.println(data); // 출력: Hello, Thread!
        
        // 스레드 데이터 제거
        MyThreadLocalData.clearThreadData();
        
        ```
        
        위의 예시에서 **`MyThreadLocalData`** 클래스는 스레드로컬을 사용하여 스레드별 데이터를 관리합니다. **`setThreadData()`** 메서드를 통해 데이터를 설정하고, **`getThreadData()`** 메서드를 통해 데이터를 조회합니다. 데이터 사용이 끝난 후에는 **`clearThreadData()`** 메서드를 사용하여 스레드로컬에서 데이터를 제거합니다.
        
        주의 사항
        
        ThreadLocal은 Thead의 정보를 key로 하여 Map의 형식으로 데이터를 저장한 후 사용할 수 있는 자료구조를 가지고 있습니다.
        
        따라서 만약 ThreadPool을 사용하여 thread를 재활용한다면
        
        동일한 이전에 세팅했던 ThreadLocal의 정보가 남아있어 원치않는 동작을 할 수 있습니다. 따라서 ThreadPool을 사용하는 경우에는 반드시 모두 사용 후 THreadLocal의 값을 remove 메서드를 사용하여 값을 제거해주는것이 필요합니다.
        
    
    4코어 서버에 싱글 스레드 서비스 인스턴스 4개로 클러스터 구성했을 때 일어날 수 있는 문제가 뭐가 있을까요
    
    - 
        
        4코어 서버에 싱글 스레드 서비스 인스턴스 4개로 클러스터를 구성했을 때 몇 가지 문제가 발생할 수 있습니다:
        
        1. 자원 경합(Race Condition): 여러 서비스 인스턴스가 동시에 같은 자원에 접근하려고 할 때 경합이 발생할 수 있습니다. 예를 들어, 동일한 파일을 동시에 쓰려고 하거나, 동일한 데이터베이스 테이블에 동시에 쓰기 작업을 수행하려고 할 때 충돌이 발생할 수 있습니다.
        2. 데이터 불일치: 각 서비스 인스턴스는 독립적인 상태를 유지하므로, 어떤 서비스 인스턴스에서 변경된 데이터가 다른 인스턴스에 반영되지 않을 수 있습니다. 이로 인해 데이터의 일관성이 깨질 수 있습니다.
        3. 부하 균형: 모든 서비스 인스턴스가 동일한 작업을 처리하는 경우, 일부 인스턴스는 과부하가 발생하고 다른 인스턴스는 비효율적으로 자원을 사용할 수 있습니다. 이로 인해 전체 시스템의 성능이 저하될 수 있습니다.
        4. 공유 자원 관리: 여러 서비스 인스턴스가 공유 자원을 사용하는 경우, 이를 적절히 동기화하고 관리해야 합니다. 동시에 접근하려는 서비스 인스턴스 간의 충돌이나 데드락(deadlock) 등의 문제가 발생할 수 있습니다.
        
        이러한 문제를 해결하기 위해 클러스터 환경에서는 적절한 동기화 메커니즘과 분산 데이터베이스, 분산 캐싱 등의 기술을 활용하여 일관성, 가용성, 성능 등을 보장하는 구조를 구현해야 합니다. 또한, 서비스 인스턴스 간의 작업 분배와 로드 밸런싱을 고려하여 자원을 효율적으로 활용할 수 있도록 해야 합니다.
        
    
    컴파일언어와 인터프리터 차이가 뭔가요?
    
    - 
        
        컴파일 언어와 인터프리터 언어는 소스 코드를 실행 가능한 형태로 변환하는 방식에 차이가 있습니다.
        
        1. 컴파일 언어:
            - 컴파일 언어는 소스 코드를 기계어로 변환하는 과정을 거친 후, 변환된 기계어 코드를 실행합니다.
            - 컴파일러(Compiler)라는 특별한 소프트웨어를 사용하여 전체 소스 코드를 한 번에 변환합니다.
            - 컴파일 언어는 변환된 기계어 코드를 실행하는 시점에서는 추가적인 변환 과정 없이 직접 실행됩니다.
            - 대표적인 컴파일 언어로는 C, C++, Java 등이 있습니다.
        2. 인터프리터 언어:
            - 인터프리터 언어는 소스 코드를 한 줄씩 읽고 해석하여 실행합니다.
            - 인터프리터(Interpreter)라는 소프트웨어가 소스 코드를 읽으면서 해당 코드를 실행합니다.
            - 인터프리터 언어는 소스 코드를 실행하는 시점에서 코드를 직접 변환하고 실행하기 때문에 컴파일 단계가 필요하지 않습니다.
            - 대표적인 인터프리터 언어로는 Python, JavaScript, Ruby 등이 있습니다.
        
        주요 차이점은 컴파일 언어는 전체 소스 코드를 한 번에 기계어로 변환한 후 실행하고, 인터프리터 언어는 소스 코드를 해석하고 실행하는 과정이 동시에 이루어진다는 점입니다. 컴파일 언어는 변환 작업을 거치기 때문에 실행 속도가 빠르고, 인터프리터 언어는 실행 시점에서 해석되기 때문에 유연성과 개발 생산성이 높을 수 있습니다.
        
    
    스택과 큐를 구현해보세요
    
    - 
        
        **. 스택(Stack) 구현 예시:**
        
        ```
        javaCopy code
        public class Stack {
            private int maxSize;
            private int[] stackArray;
            private int top;
        
            public Stack(int size) {
                maxSize = size;
                stackArray = new int[maxSize];
                top = -1;
            }
        
            public void push(int value) {
                if (top < maxSize - 1) {
                    stackArray[++top] = value;
                } else {
                    System.out.println("Stack is full. Cannot push element.");
                }
            }
        
            public int pop() {
                if (top >= 0) {
                    return stackArray[top--];
                } else {
                    System.out.println("Stack is empty. Cannot pop element.");
                    return -1;
                }
            }
        
            public int peek() {
                if (top >= 0) {
                    return stackArray[top];
                } else {
                    System.out.println("Stack is empty. Cannot peek element.");
                    return -1;
                }
            }
        
            public boolean isEmpty() {
                return top == -1;
            }
        
            public boolean isFull() {
                return top == maxSize - 1;
            }
        }
        
        ```
        
        **2. 큐(Queue) 구현 예시:**
        
        ```
        javaCopy code
        public class Queue {
            private int maxSize;
            private int[] queueArray;
            private int front;
            private int rear;
            private int size;
        
            public Queue(int size) {
                maxSize = size;
                queueArray = new int[maxSize];
                front = 0;
                rear = -1;
                size = 0;
            }
        
            public void enqueue(int value) {
                if (size < maxSize) {
                    if (rear == maxSize - 1) {
                        rear = -1;
                    }
                    queueArray[++rear] = value;
                    size++;
                } else {
                    System.out.println("Queue is full. Cannot enqueue element.");
                }
            }
        
            public int dequeue() {
                if (size > 0) {
                    int value = queueArray[front++];
                    if (front == maxSize) {
                        front = 0;
                    }
                    size--;
                    return value;
                } else {
                    System.out.println("Queue is empty. Cannot dequeue element.");
                    return -1;
                }
            }
        
            public int peek() {
                if (size > 0) {
                    return queueArray[front];
                } else {
                    System.out.println("Queue is empty. Cannot peek element.");
                    return -1;
                }
            }
        
            public boolean isEmpty() {
                return size == 0;
            }
        
            public boolean isFull() {
                return size == maxSize;
            }
        }
        
        ```
        
        위의 코드는 스택(Stack)과 큐(Queue)의 간단한 구현 예시입니다. 스택은 LIFO(Last In, First Out) 구조로 요소를 추가(push)하고 제거(pop)합니다. 큐는 FIFO(First In, First Out) 구조로 요소를 추가(enqueue)하고 제거(dequeue)합니다. 위의 예시는 배열을 사용하여 구현되었으며, 기본적인 연산과 예외 처리를 포함하고 있습니다.
        
    
    스택으로 큐를 구현해보세요
    
    - 
        
        스택(Stack)을 사용하여 큐(Queue)를 구현하는 예시입니다. 이를 "두 개의 스택을 사용한 큐 구현"이라고 할 수 있습니다.
        
        ```
        javaCopy code
        import java.util.Stack;
        
        public class QueueWithStacks<T> {
            private Stack<T> stack1;  // 입력 스택
            private Stack<T> stack2;  // 출력 스택
        
            public QueueWithStacks() {
                stack1 = new Stack<>();
                stack2 = new Stack<>();
            }
        
            public void enqueue(T item) {
                stack1.push(item);  // 입력 스택에 요소 추가
            }
        
            public T dequeue() {
                if (stack2.isEmpty()) {
                    // 출력 스택이 비어있을 경우 입력 스택의 요소를 모두 출력 스택으로 이동
                    while (!stack1.isEmpty()) {
                        stack2.push(stack1.pop());
                    }
                }
                return stack2.pop();  // 출력 스택에서 요소 제거 및 반환
            }
        
            public T peek() {
                if (stack2.isEmpty()) {
                    // 출력 스택이 비어있을 경우 입력 스택의 요소를 모두 출력 스택으로 이동
                    while (!stack1.isEmpty()) {
                        stack2.push(stack1.pop());
                    }
                }
                return stack2.peek();  // 출력 스택의 가장 앞에 있는 요소 반환
            }
        
            public boolean isEmpty() {
                return stack1.isEmpty() && stack2.isEmpty();
            }
        
            public int size() {
                return stack1.size() + stack2.size();
            }
        }
        
        ```
        
        위의 코드는 두 개의 스택을 사용하여 큐를 구현한 예시입니다. enqueue 메서드는 입력 스택에 요소를 추가하고, dequeue 메서드는 출력 스택에서 요소를 제거하여 반환합니다. 만약 출력 스택이 비어있는 경우에는 입력 스택의 요소를 모두 출력 스택으로 이동시킵니다. peek 메서드는 출력 스택의 가장 앞에 있는 요소를 반환합니다. isEmpty 메서드는 큐가 비어있는지 여부를 확인하고, size 메서드는 큐의 크기를 반환합니다.
        
    
    1부터 100까지 재귀합 구현해보세요
    
    - 
        
        재귀적으로 1부터 n까지의 합을 구하는 함수를 구현해보겠습니다.
        
        ```
        javaCopy code
        public class RecursiveSum {
            public static int recursiveSum(int n) {
                if (n == 1) {
                    return 1;
                } else {
                    return n + recursiveSum(n - 1);
                }
            }
        
            public static void main(String[] args) {
                int sum = recursiveSum(100);
                System.out.println("1부터 100까지의 합: " + sum);
            }
        }
        
        ```
        
        위의 코드에서 **`recursiveSum`** 함수는 재귀적으로 1부터 n까지의 합을 계산합니다. 재귀적인 방식을 사용하여 n이 1일 때는 1을 반환하고, 그 외의 경우에는 n과 **`recursiveSum(n - 1)`**의 합을 반환합니다. **`main`** 함수에서는 **`recursiveSum`** 함수를 호출하여 1부터 100까지의 합을 계산하고 출력합니다.
        
    
    퀵정렬에 대해 설명해주세요.
    
    - 
        
        퀵소트(Quick Sort)는 분할 정복(Divide and Conquer) 알고리즘을 기반으로 하는 정렬 알고리즘입니다. 아래는 간단한 자바 코드로 퀵소트를 구현한 예시입니다:
        
        ```
        javaCopy code
        public class QuickSort {
            public static void quickSort(int[] arr, int low, int high) {
                if (low < high) {
                    int pivotIndex = partition(arr, low, high);
                    quickSort(arr, low, pivotIndex - 1);
                    quickSort(arr, pivotIndex + 1, high);
                }
            }
        
            public static int partition(int[] arr, int low, int high) {
                int pivot = arr[high];
                int i = low - 1;
        
                for (int j = low; j < high; j++) {
                    if (arr[j] < pivot) {
                        i++;
                        swap(arr, i, j);
                    }
                }
        
                swap(arr, i + 1, high);
                return i + 1;
            }
        
            public static void swap(int[] arr, int i, int j) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        
            public static void main(String[] args) {
                int[] arr = {9, 3, 7, 5, 1, 6};
                int n = arr.length;
        
                System.out.println("Before sorting:");
                for (int num : arr) {
                    System.out.print(num + " ");
                }
        
                quickSort(arr, 0, n - 1);
        
                System.out.println("\nAfter sorting:");
                for (int num : arr) {
                    System.out.print(num + " ");
                }
            }
        }
        
        ```
        
        위의 코드에서 **`quickSort`** 메서드는 분할 정복을 사용하여 배열을 재귀적으로 정렬합니다. **`partition`** 메서드는 배열을 pivot을 기준으로 분할하고 pivot의 위치를 반환합니다. **`swap`** 메서드는 배열의 두 원소를 교환하는 역할을 합니다.
        
        자바에서 정렬은 **`Arrays.sort`** 메서드를 사용하며, 기본적으로 퀵소트 알고리즘을 사용합니다. 그러나 작은 크기의 배열에 대해서는 다른 알고리즘(주로 삽입 정렬)을 사용하기도 합니다. 또한, 객체를 정렬할 때에는 객체의 **`Comparable`** 인터페이스를 구현하거나 **`Comparator`** 인터페이스를 사용하여 정렬 순서를 지정할 수 있습니다.
        
    
    자바 Arrays.sort는 어떤건가요?
    
    - 
        
        정확한 표현은 "팀소트(Timsort)"입니다. 팀소트(Timsort)는 퀵소트(Quick Sort)와 삽입 정렬(Insertion Sort)을 결합한 안정적인 정렬 알고리즘입니다. 자바의 **`Arrays.sort`** 및 **`Collections.sort`** 메서드에서 사용되는 기본 정렬 알고리즘이 팀소트(Timsort)입니다.
        
        팀소트(Timsort)는 크게 두 단계로 구성됩니다. 첫 번째 단계는 배열을 작은 조각으로 분할하고 각 조각을 삽입 정렬로 정렬합니다. 두 번째 단계에서는 작은 조각들을 병합하여 최종적으로 정렬된 배열을 생성합니다. 이렇게 분할 정복(Divide and Conquer) 방식으로 동작하며, 이미 정렬된 부분 배열이나 부분적으로 정렬된 배열에 대해서도 효율적으로 동작합니다.
        
        퀵소트(Quick Sort)는 평균적으로 빠른 속도를 가지지만, 최악의 경우 시간 복잡도가 O(n^2)이 될 수 있습니다. 반면에 팀소트(Timsort)는 퀵소트(Quick Sort)와 삽입 정렬(Insertion Sort)을 결합하여 안정적이고 효율적인 정렬을 제공합니다. 팀소트(Timsort)는 일반적으로 대부분의 상황에서 효율적이며, 이미 정렬된 데이터나 거의 정렬된 데이터에 대해서도 좋은 성능을 보입니다.
        
        따라서, 자바에서의 기본 정렬 알고리즘은 팀소트(Timsort)입니다. 팀소트(Timsort)는 퀵소트(Quick Sort)와 삽입 정렬(Insertion Sort)의 장점을 결합하여 안정적이고 효율적인 정렬을 수행합니다.
        
    
    jvm에 대해 설명해주세요
    
    - 
        
        ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1,%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%207025ec5fc38d43dcaa213e01af9b519f/Untitled%202.png)
        
        JVM(Java Virtual Machine)은 자바 언어로 작성된 애플리케이션을 실행하기 위한 가상 머신입니다. JVM은 운영체제와 자바 애플리케이션 사이에서 중개자 역할을 수행하여 자바 애플리케이션을 운영체제에 독립적으로 실행할 수 있게 해줍니다.
        
        JVM은 크게 세 가지 주요 컴포넌트로 구성됩니다.
        
        1. Class Loader(클래스 로더): JVM은 클래스 파일을 동적으로 로드하여 메모리에 올리는 역할을 수행합니다. 클래스 로더는 필요한 클래스를 찾고 로드하며, 이를 통해 애플리케이션 실행에 필요한 클래스들을 사용할 수 있게 됩니다.
        2. Execution Engine(실행 엔진): JVM은 자바 바이트코드를 기계어로 변환하고 실행하는 실행 엔진을 포함하고 있습니다. 실행 엔진은 자바 바이트코드를 한 줄씩 읽어 해석하거나, 인터프리터를 사용하여 실행하거나, JIT(Just-In-Time) 컴파일러를 통해 바이트코드를 기계어로 컴파일하여 실행할 수 있습니다.
        3. Garbage Collector(가비지 컬렉터): JVM은 자동 메모리 관리를 위해 가비지 컬렉터를 제공합니다. 가비지 컬렉터는 더 이상 사용되지 않는 객체들을 자동으로 탐지하고 제거하여 메모리를 회수합니다. 이를 통해 개발자는 명시적으로 메모리를 관리하지 않아도 됩니다.
        
        JVM은 자바 언어의 특성인 운영체제에 독립적인 실행 환경을 제공하고, 메모리 관리, 스레드 관리, 예외 처리 등의 기능을 제공하여 안정적이고 효율적인 자바 애플리케이션 실행을 가능하게 합니다.
        
    
    dfs와 bfs는 무엇인가요?
    
    - 
        
        DFS(Depth-First Search, 깊이 우선 탐색)와 BFS(Breadth-First Search, 너비 우선 탐색)는 그래프 탐색 알고리즘 중 두 가지 주요한 방법론입니다. 이 알고리즘들은 주어진 그래프에서 노드를 탐색하거나 탐색 순서를 결정하는 데 사용됩니다.
        
        - DFS(Depth-First Search):
        DFS는 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘입니다. 시작 노드에서부터 한 방향으로 최대한 깊이 탐색한 뒤, 더 이상 갈 곳이 없으면 이전 단계로 돌아와 다른 방향으로 탐색을 진행합니다. DFS는 스택(Stack) 또는 재귀(Recursion)를 통해 구현할 수 있습니다. DFS는 미로 찾기, 그래프의 연결 여부 확인, 트리 순회 등 다양한 문제에 활용됩니다.
        - BFS(Breadth-First Search):
        BFS는 그래프의 가까운 부분을 우선적으로 탐색하는 알고리즘입니다. 시작 노드에서부터 인접한 노드를 모두 탐색한 뒤, 그 인접한 노드들과 다시 인접한 노드들을 탐색하는 방식으로 진행합니다. BFS는 큐(Queue)를 사용하여 구현할 수 있습니다. BFS는 최단 경로 탐색, 네트워크 트래픽 분석, 소셜 네트워크 분석 등에 활용됩니다.
        
        트리는 계층적인 구조를 가진 비선형 자료구조로, DFS와 BFS를 트리에 적용할 수 있습니다. 트리에서 DFS는 한 노드의 자식 노드들을 모두 탐색한 뒤 다음 형제 노드로 이동하면서 탐색을 진행합니다. BFS는 한 레벨의 모든 노드를 탐색한 뒤 다음 레벨로 넘어가면서 탐색을 진행합니다. DFS는 깊이에 따라 탐색하고, BFS는 너비에 따라 탐색하는 특성을 가지고 있습니다.
        
    
    바이너리 트리와 바이너리 서치 트리는 무엇인가요?
    
    - 
        1. 구성 요소:
            - 바이너리 트리(Binary Tree): 각 노드는 최대 두 개의 자식 노드를 가질 수 있습니다. 자식 노드의 개수에 제약이 없으며, 자식 노드의 위치(왼쪽 또는 오른쪽)에 따라 구분됩니다.
            - 바이너리 서치 트리(Binary Search Tree): 바이너리 트리의 일종으로, 각 노드의 값은 해당 노드의 왼쪽 서브트리에 속하는 모든 노드의 값보다 작고, 오른쪽 서브트리에 속하는 모든 노드의 값보다 큽니다.
        2. 정렬:
            - 바이너리 트리: 자식 노드의 순서에 따라 구분되며, 정렬된 상태를 갖지 않습니다.
            - 바이너리 서치 트리: 각 노드의 값은 왼쪽 서브트리에 속하는 모든 노드의 값보다 작고, 오른쪽 서브트리에 속하는 모든 노드의 값보다 크기 때문에 정렬된 상태를 유지합니다.
        3. 탐색, 삽입, 삭제:
            - 바이너리 트리: 탐색, 삽입, 삭제 등의 연산에 특별한 제약이 없습니다. 일반적으로 트리의 구조를 유지하면서 원하는 노드를 탐색하거나 추가/삭제할 수 있습니다.
            - 바이너리 서치 트리: 트리의 정렬된 특성을 활용하여 탐색, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있습니다. 탐색 연산은 이진 탐색 알고리즘을 사용하여 빠르게 수행할 수 있으며, 삽입과 삭제 연산은 트리의 구조를 유지하면서 이루어집니다.
    
    string, string buffer, string builder 차이
    
    - 
        
        **`String`**, **`StringBuffer`**, **`StringBuilder`**는 모두 문자열을 다루는 클래스입니다. 주요 차이점은 다음과 같습니다:
        
        1. 가변성:
            - **`String`**: **`String`** 객체는 불변(Immutable)입니다. 한 번 생성된 문자열은 변경할 수 없으며, 문자열 연산을 수행할 때마다 새로운 **`String`** 객체가 생성됩니다.
            - **`StringBuffer`**와 **`StringBuilder`**: **`StringBuffer`**와 **`StringBuilder`** 객체는 가변(Mutable)입니다. 문자열 연산을 수행할 때 원본 객체를 직접 변경합니다.
        2. 스레드 안전성:
            - **`String`**: **`String`** 객체는 스레드 안전(thread-safe)합니다. 여러 스레드가 동시에 **`String`** 객체를 사용해도 안전하게 접근할 수 있습니다.
            - **`StringBuffer`**: **`StringBuffer`**는 스레드 안전한 클래스입니다. 여러 스레드가 동시에 **`StringBuffer`** 객체를 사용해도 동기화를 통해 안전한 접근이 보장됩니다.
            - **`StringBuilder`**: **`StringBuilder`**는 **`StringBuffer`**와 비슷한 기능을 제공하지만, 스레드 안전성을 보장하지 않습니다. **`StringBuilder`**는 단일 스레드 환경에서의 사용에 적합합니다.
        3. 성능:
            - **`String`**: **`String`** 객체는 불변성으로 인해 안정적이고 예측 가능한 동작을 제공하지만, 문자열 연산이 필요한 작업이 많을 때 성능에 영향을 줄 수 있습니다.
            - **`StringBuffer`**와 **`StringBuilder`**: 가변성으로 인해 문자열 연산이 원본 객체에서 직접 수행되므로 성능상 이점을 가집니다. **`StringBuffer`**는 동기화를 지원하므로 멀티스레드 환경에서 안전하게 사용할 수 있지만, **`StringBuilder`**는 단일 스레드 환경에서의 사용을 권장합니다.
        
        따라서, 다음과 같은 상황에서 사용을 고려할 수 있습니다:
        
        - 문자열을 변경하지 않고 단순히 읽기만 하는 경우: **`String`**
        - 문자열을 변경해야 하며, 멀티스레드 환경에서 안전하게 사용해야 하는 경우: **`StringBuffer`**
        - 문자열을 변경해야 하며, 단일 스레드 환경에서 사용하는 경우: **`StringBuilder`**
    
    퀵 소트(Quick Sort)와 머지 소트(Merge Sort)의 시간 복잡도
    
    - 
        
        퀵 소트(Quick Sort)와 머지 소트(Merge Sort)의 시간 복잡도는 다음과 같습니다:
        
        1. 퀵 소트의 시간 복잡도:
            - 평균 시간 복잡도: O(n log n)
            - 최악의 경우 시간 복잡도: O(n^2)
            - 퀵 소트는 평균적으로 매우 빠른 정렬 알고리즘으로 알려져 있습니다. 평균 시간 복잡도인 O(n log n)을 가지지만, 최악의 경우 정렬된 배열이나 거의 정렬된 배열에서는 효율성이 떨어집니다. 최악의 경우 시간 복잡도인 O(n^2)를 가질 수 있습니다. 하지만 퀵 소트는 대부분의 경우에 효과적이며, 일반적으로 많이 사용됩니다.
        2. 머지 소트의 시간 복잡도:
            - 항상 일정한 시간 복잡도: O(n log n)
            - 머지 소트는 항상 일정한 시간 복잡도 O(n log n)를 가집니다. 입력 크기에 상관없이 두 개의 하위 배열로 분할한 다음 병합하는 과정을 반복하여 정렬을 수행합니다. 따라서 머지 소트는 입력이 어떠한 경우에도 일정한 성능을 제공합니다. 하지만 퀵 소트보다는 약간 더 많은 메모리를 사용하는 단점이 있습니다.
        
        둘 다 평균적으로 입력 크기에 대해 O(n log n)의 시간 복잡도를 가지지만, 퀵 소트는 최악의 경우에도 O(n^2)의 시간 복잡도를 가질 수 있으므로 입력 데이터의 특성에 따라 선택해야 할 필요가 있습니다. 퀵 소트는 평균적인 경우에 더 빠른 속도를 보이는 경향이 있으며, 머지 소트는 입력 데이터가 이미 정렬되어 있거나 부분적으로 정렬된 경우에도 일관된 성능을 보장합니다.
        
    
    자바로 2진수를 10진수로 변환해봐라
    
    - 
        
        ```java
        String binaryString = "101010"; // 2진수 문자열
        int decimal = Integer.valueOf(binaryString, 2);
        System.out.println(decimal); // 출력: 42
        ```
        
    
    자바로 10진수를 2진수로 변환해봐라
    
    - 
        
        ```java
        int decimal = 42; // 10진수
        String binaryString = Integer.toString(decimal, 2);
        System.out.println(binaryString); // 출력: 101010
        ```
        
    
    자바로 16진수를 10진수로 변환해라
    
    - 
        
        ```java
        String hex = "2A"; // 16진수
        int decimal = Integer.parseInt(hex, 16);
        System.out.println(decimal); // 출력: 42
        ```
        
    
    [3,2,7,3,2,7,5,8] 중복제거및 순서유지 해봐라
    
    - 
        
        ```
        avaCopy code
        import java.util.ArrayList;
        import java.util.LinkedHashSet;
        import java.util.List;
        import java.util.Set;
        
        public class Main {
            public static void main(String[] args) {
                List<Integer> numbers = new ArrayList<>();
                numbers.add(3);
                numbers.add(2);
                numbers.add(7);
                numbers.add(3);
                numbers.add(2);
                numbers.add(7);
                numbers.add(5);
                numbers.add(8);
        
                // 중복 제거 및 순서 유지를 위해 LinkedHashSet 사용
                Set<Integer> uniqueNumbers = new LinkedHashSet<>(numbers);
        
                // 결과를 다시 List로 변환
                List<Integer> result = new ArrayList<>(uniqueNumbers);
        
                System.out.println(result); // 출력: [3, 2, 7, 5, 8]
            }
        }
        
        ```
        
        위 코드에서 **`numbers`** 리스트에 중복된 숫자들이 포함되어 있습니다. **`LinkedHashSet`**을 사용하여 중복을 제거하고, 그 결과를 다시 **`List`**로 변환하여 순서를 유지합니다. 마지막으로, **`result`** 리스트를 출력하면 중복이 제거되고 순서가 유지된 결과가 나타납니다.
        
    
    mutable, immutable 차이
    
    - 
        
        Mutable(가변)과 Immutable(불변)은 객체의 상태 변경 가능성에 대한 개념입니다.
        
        Mutable 객체는 생성 후에 내부 상태를 변경할 수 있습니다. 즉, 객체의 속성이나 상태를 수정하거나 업데이트할 수 있습니다. 예를 들면, Java의 **`StringBuilder`**이나 **`ArrayList`**와 같은 클래스가 가변 객체입니다. 이러한 객체는 자유롭게 상태를 변경할 수 있으나, 여러 스레드 간에 동시에 접근하면 동기화 문제가 발생할 수 있습니다.
        
        반면, Immutable 객체는 생성 후에 내부 상태를 변경할 수 없습니다. 객체가 한 번 생성되면 그 상태는 영구적으로 고정되어 수정될 수 없습니다. 예를 들면, Java의 **`String`**이나 **`Integer`**와 같은 클래스가 불변 객체입니다. 이러한 객체는 스레드 안전하며, 동기화 문제를 걱정할 필요가 없습니다. 또한, 불변 객체는 예측 가능하고 안정적인 동작을 보장하며, 캐싱 및 재사용이 용이합니다.
        
        불변 객체의 장점은 다음과 같습니다:
        
        - 스레드 안전성: 여러 스레드에서 동시에 접근해도 객체의 내부 상태가 변경되지 않으므로 동기화 문제가 발생하지 않습니다.
        - 안전성: 불변 객체는 수정되지 않으므로 의도치 않은 변경이나 부작용이 발생할 수 없습니다.
        - 캐싱 및 재사용: 동일한 값을 가진 객체는 한 번만 생성되고 재사용될 수 있습니다. 이로 인해 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다.
        
        Mutable 객체는 상태 변경이 자유롭고 유연한 동작이 필요한 경우에 적합합니다. 하지만 상태 변경에 따른 부작용이나 동기화 문제를 주의해야 합니다. Immutable 객체는 안정성과 예측 가능성이 필요한 경우에 적합합니다. 또한, 병렬 처리나 함수형 프로그래밍과 같은 환경에서 유용하게 사용될 수 있습니다.
        
    
    final 키워드 쓰는 이유
    
    - 
        
        private 필드에 final을 붙이는 것은 좋은 습관입니다. 이는 필드의 불변성(immutable)을 보장하고 객체의 상태를 안정적으로 유지할 수 있도록 도와줍니다.
        
        final 키워드를 사용하면 해당 필드는 초기화된 이후에는 더 이상 변경할 수 없습니다. 이로써 필드의 값은 객체의 수명 동안 일관되고 예측 가능한 상태를 유지합니다. 이는 다음과 같은 이점을 제공합니다:
        
        안정성: final 필드는 다른 코드에서 의도치 않은 변경으로부터 보호됩니다. 필드가 불변하므로 다른 코드에서 잘못된 값으로 수정되는 위험이 없습니다.
        
        스레드 안전성: final 필드는 스레드 간의 동기화 문제를 방지합니다. 초기화 후에는 필드의 값을 변경할 수 없으므로 스레드 간의 경쟁 조건이 발생하지 않습니다.
        
        가독성: final 필드는 코드의 의도를 명확하게 전달합니다. 필드가 변경되지 않을 것이라는 것을 명시적으로 나타내므로 코드의 가독성을 높일 수 있습니다.
        
        성능: final 필드는 JVM이 필드를 캐시하고 최적화하는 데 도움을 줄 수 있습니다. 불필요한 메모리 할당이나 중복된 값의 계산을 피할 수 있습니다.
        
        하지만 final 필드에 대한 주의사항도 있습니다. final 필드가 있는 클래스의 불변성은 해당 클래스의 내부 상태에만 적용됩니다. 즉, final 필드가 참조하는 객체의 상태는 변경될 수 있습니다. 이를 방지하기 위해서는 불변 객체(immutable object)로 구현되어야 합니다.
        
        또한, final 필드가 있는 클래스의 상속에 대한 제약이 있을 수 있습니다. final 필드가 있는 클래스를 상속하면 해당 필드를 재정의할 수 없습니다.
        
        따라서, private 필드에 final을 붙이는 것은 객체의 안정성과 일관성을 유지하기 위해 권장되는 좋은 습관입니다. 하지만 final 필드를 사용할 때는 해당 필드의 불변성이 보장되는지 신중하게 고려해야 합니다.
        
    
    동기와 비동기의 차이가 뭔가요?
    
    - 
        
        동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 작업의 처리 방식을 나타내는 용어입니다.
        
        동기는 작업을 순차적으로 진행하며, 한 작업이 끝나야 다음 작업을 실행하는 방식입니다. 즉, 작업이 호출되면 해당 작업이 완료될 때까지 대기하고, 결과를 받아온 후에 다음 작업을 진행합니다. 이 때문에 작업이 순차적으로 처리되기 때문에 작업의 진행 상태와 결과를 예측하기 쉽고, 코드가 간단하고 직관적일 수 있습니다. 하지만 작업이 완료될 때까지 대기해야 하므로 다른 작업을 동시에 수행할 수 없고, 작업이 블로킹(blocking)될 수 있어 전체적인 성능에 영향을 줄 수 있습니다.
        
        비동기는 작업을 동시에 실행하고, 결과를 기다리지 않고 다른 작업을 동시에 처리하는 방식입니다. 작업이 호출되면 해당 작업은 백그라운드에서 동작하고, 결과를 기다리지 않고 다음 작업을 실행합니다. 작업의 완료 여부나 결과는 콜백(callback)이나 이벤트 등을 통해 알 수 있습니다. 이러한 방식은 작업을 동시에 처리하므로 블로킹되지 않고 다른 작업을 동시에 수행할 수 있습니다. 따라서 전체적인 성능과 응답성을 향상시킬 수 있습니다. 그러나 비동기 처리는 작업의 진행 상태를 추적하거나 작업 간의 순서를 보장하기 어려울 수 있으며, 코드가 복잡해질 수 있습니다.
        
        요약하면, 동기는 작업을 순차적으로 처리하고 결과를 기다리는 방식이며, 비동기는 작업을 동시에 처리하고 결과를 기다리지 않고 다른 작업을 실행하는 방식입니다. 선택은 작업의 특성과 요구사항에 따라 달라집니다. 동기 방식은 간단하고 직관적이지만 성능과 응답성 측면에서 제한이 있을 수 있고, 비동기 방식은 성능과 응답성을 향상시킬 수 있지만 코드가 복잡해질 수 있습니다.
        
    
    `Blocking IO` **가 일어나면 스레드에는 무슨 일이 생길까요?**
    
    - 
        
        **`Blocking IO`**는 입력 및 출력 작업이 완료될 때까지 스레드를 차단(Blocking)시키는 동작입니다. 이 경우 스레드는 작업이 완료될 때까지 대기하게 됩니다.
        
        일반적으로 **`Blocking IO`** 작업이 발생하면 스레드는 해당 작업이 완료될 때까지 다른 작업을 수행할 수 없습니다. 스레드는 작업이 끝날 때까지 블록 상태로 남게 되며, 다른 스레드들은 CPU 시간을 할당받아 다른 작업을 수행할 수 있습니다.
        
        따라서, **`Blocking IO`** 작업이 발생하면 해당 스레드는 작업이 완료되기를 기다리면서 자원을 낭비하게 됩니다. 다른 작업을 수행할 수 있는 스레드가 있음에도 불구하고 차단된 스레드는 대기하므로 전체적인 시스템 성능이 저하될 수 있습니다.
        
        이러한 이유로 **`Blocking IO`** 작업은 일반적으로 멀티스레드 환경에서 사용될 때 주의가 필요합니다. 많은 수의 **`Blocking IO`** 작업이 동시에 발생하면 스레드 풀의 리소스를 과도하게 소비하여 성능 저하나 데드락 등의 문제가 발생할 수 있습니다. 이러한 상황을 방지하기 위해 비동기적인 IO 처리 방식을 사용하거나, **`Blocking IO`** 작업을 처리하는 별도의 스레드 풀을 생성하여 관리하는 등의 대안을 고려할 수 있습니다.
        
        스**레드가 멈춰있는 동안 CPU는 어떻게 될까요?**
        
        **CPU가 쉬는 것을 막으려면 어떻게 해야할까요?**
        
        **스레드를 늘리면 단점이 무엇일까요?**
        
        `Non-Blocking IO`**는 CPU 활용률이 어떨까요?**
        
    
    Runnable과 Thread 상속의 차이는 무엇인가?
    
    - 
        
        Runnable과 Thread를 사용하여 스레드를 구현하는 방식에는 몇 가지 차이점이 있습니다.
        
        1. 상속 가능성:
            - Thread 클래스를 상속하여 스레드를 구현하면 다른 클래스를 상속받을 수 없습니다. 자바는 단일 상속만을 지원하기 때문에, 이미 다른 클래스를 상속받고 있는 경우에는 Thread 클래스를 상속할 수 없습니다.
            - Runnable 인터페이스를 구현하여 스레드를 구현하면 다른 클래스를 상속받고 있더라도 Runnable 인터페이스를 구현할 수 있습니다. 이는 클래스의 확장성과 유연성을 높일 수 있는 장점이 있습니다.
        2. 코드 재사용성:
            - Runnable 인터페이스를 구현하는 방식은 코드의 재사용성을 높일 수 있습니다. Runnable 객체는 다른 스레드와 공유될 수 있으며, 여러 스레드가 동일한 Runnable 객체를 실행할 수 있습니다. 따라서 Runnable을 구현한 객체를 여러 스레드에서 실행하거나 스레드 풀에 넣어 재사용할 수 있습니다.
            - Thread 클래스를 상속한 방식은 스레드마다 별도의 인스턴스를 생성해야 합니다. 스레드마다 독립적인 인스턴스를 생성해야 하므로 코드의 재사용성이 낮아집니다.
        3. 디자인 관점:
            - Runnable 인터페이스를 구현하는 방식은 "구현에 의한 다형성"을 활용하는 디자인 패턴에 더 가깝습니다. 스레드가 실행할 작업을 분리하여 정의하는 것으로, 작업과 스레드를 분리함으로써 더 모듈화된 디자인을 구현할 수 있습니다.
            - Thread 클래스를 상속하는 방식은 "상속에 의한 다형성"을 활용하는 디자인 패턴에 가깝습니다. 스레드 클래스를 상속받아 스레드 자체에 작업을 포함하는 것으로, 스레드와 작업이 하나의 단일 개체로 표현됩니다.
        
        따라서, Runnable 인터페이스를 구현하는 방식은 코드의 재사용성과 디자인의 유연성을 높일 수 있으며, 다중 상속이 필요한 경우나 이미 다른 클래스를 상속받고 있는 경우에 유용합니다. Thread 클래스를 상속하는 방식은 간단하게 스레드를 구현할 수 있지만, 상속의 한계와 코드 재사용성의 저하 등의 단점이 있을 수 있
        
    
    부동소수점과 고정소수점에 대해 설명해주세요
    
    - 
        
        부동소수점(Floating-Point)과 고정소수점(Fixed-Point)은 소수를 표현하는 두 가지 방법입니다.
        
        1. 부동소수점:
        부동소수점은 실수를 표현하기 위한 방법 중 하나로, 소수점을 고정된 위치에 두지 않고 지수와 가수의 형태로 표현합니다. IEEE 754 표준에 따라 대부분의 컴퓨터 시스템에서 부동소수점을 사용합니다.
        
        부동소수점은 일정한 정밀도를 가지며 큰 범위의 실수를 표현할 수 있습니다. 그러나 부동소수점 연산은 정밀도 손실과 반올림 오차가 발생할 수 있습니다. 이는 이진법으로 표현되기 때문에 10진법으로 표현되는 실수와 완전히 정확히 매치되지 않을 수 있음을 의미합니다.
        
        자바에서 부동소수점은 **`float`**과 **`double`** 데이터 타입으로 표현됩니다. **`float`**은 32비트 단정밀도 부동소수점이고, **`double`**은 64비트 배정밀도 부동소수점입니다.
        
        1. 고정소수점:
        고정소수점은 소수점 위치가 고정되어 있고 정수부와 소수부의 비트 수가 고정된 형태로 표현됩니다. 소수를 정수로 표현하며 곱셈 및 나눗셈 연산에 효율적입니다.
        
        고정소수점은 정확한 소수 표현과 연산이 가능하지만, 표현 가능한 범위가 제한적입니다. 또한, 정수부와 소수부의 비트 수를 사전에 정해야 하기 때문에 표현 가능한 값의 범위와 정밀도가 사전에 결정됩니다.
        
        고정소수점은 자바에서 직접 제공되는 데이터 타입은 아니지만, 필요한 경우 고정소수점을 표현하기 위해 정수형 데이터 타입을 사용하고 소수점 위치를 약속된 비트로 표현하는 방법을 사용할 수 있습니다.
        
        정리하면, 부동소수점은 실수 표현을 위한 형태로 범위가 크고 정밀도가 제한적이며, 고정소수점은 정확한 소수 표현과 연산이 가능하지만 범위가 제한되고 사전에 비트 수를 정해야 합니다. 어떤 표현 방식을 선택할지는 사용하고자 하는 값의 범위와 정확도 요구사항
        
    
    **G1GC와 ZGC에 대해 설명해주세요**
    
    - 
        
        G1GC는 JDK 11 Default GC로 기존의 Young,Old 영역으로 나눈 것이 아닌 Heap을 Region이라는 특정 크기로 나누고, GC대상 객체가 발견된 각각의 Region에만 GC 발생합니다.
        
        ZGC는 큰 메모리에서 효율적인 GC를 위한 GC로 JDK 15에서 준비중인 GC입니다.Colored Pointers와 Load Barriers 알고리즘을 통해 객체를 Marking하고 관리하게 됩니다.
        
        ZGC는 확장이 가능하고 저지연(STW 10MS이하가 목표) GC입니다.
        
    
    BigInteger를 사용하는 이유가 뭔가요?
    
    - 
        
        Java에서 **`BigInteger`**는 임의의 크기의 정수를 표현하고 다양한 연산을 수행할 수 있는 클래스입니다. **`BigInteger`**를 사용하는 이유는 다음과 같습니다:
        
        1. 정밀한 정수 표현: **`BigInteger`**는 **`int`** 또는 **`long`**과 같은 기본 정수 타입의 표현 범위를 넘어서는 매우 큰 수를 다룰 수 있습니다. 따라서 정확성이 요구되는 대규모 정수 계산에 유용합니다.
        2. 정밀한 연산: **`BigInteger`**는 정수 간의 연산에 대해 다양한 메서드를 제공합니다. 이에는 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 계산 등이 포함됩니다. 이러한 연산은 정수의 크기에 관계없이 정확한 결과를 제공합니다.
        3. 소수 및 암호화 관련 작업: **`BigInteger`**는 소수 생성, 소수 판별, 암호화 알고리즘과 같은 작업에 유용합니다. 큰 소수를 생성하고 검증하거나, RSA 암호화와 같은 알고리즘을 구현하는 데에 활용될 수 있습니다.
        4. 불변성: **`BigInteger`**는 불변(immutable) 객체로 설계되어 있어, 한 번 생성된 후에는 내부 값이 변경되지 않습니다. 이는 다중 스레드 환경에서 안전하게 사용할 수 있도록 합니다.
        
        하지만 **`BigInteger`**는 기본 정수 타입보다 연산 속도가 느리고 메모리 사용량이 더 많기 때문에, 일반적인 정수 계산에는 기본 정수 타입을 사용하는 것이 성능상 유리합니다. 
        
        **`BigInteger`**는 정밀한 정수 연산이 필요한 특정 상황에서 사용되며, 정확성과 유연성이 우선시되는 경우에 유용합니다.
        
    
    println에서 `synchronized` 가 `Blocking IO` 와 만나면 어떻게 성능하락을 만들 수 있는걸까요?
    
    - 
    
    위 두개가 만날때 스레드가 어떻게 동작할지, CPU 사용률은 어떻게 될지 시뮬레이션 해주세요
    
    - 
    
    **갑자기** `Out of Memory Error(OOM)`**를 내며 프로세스가 종료되었습니다. 어떻게 대처해볼 수 있을까요?(힙 덤프란 무엇인가요?)**
    
    - 
    
    **어플리케이션이 종료된 상태에서 힙덤프를 생성하는게 가능한가요?**
    
    - 
    
    불변과 final을 쓰는 이유
    
    - 
        
        1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
        
        (공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)
        
        2. 실패 원자적인 메소드를 만들 수 있다.
        
        (어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)
        
        3. 부수효과를 피해 오류를 최소화 할 수 있다.
        
        ※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상
        
        4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
        
        5. 가비지 컬렉션 성능을 높일 수 있다.
        
        (가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)
        
    
    Optional API에 대해 설명해주세요.
    
    - 
        
        개발할때 가장 많이 발생하는 예외 중 하나가 NPE(NullPointerException)입니다.
        
        NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거롭습니다. 하지만 Java8 부터 Optional<T>을 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있습니다.
        
    
    Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.
    
    - 
        
        hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
        
        해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 이 두 개가 모두 맞으면 중복 객체입니다.
        
    
    final / finally / finalize 의 차이를 설명해주세요.
    
    - 
        - **final**은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용합니다.
            - final 변수는 한 번 초기화되면 그 이후에 변경할 수 없습니다.
            - final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지합니다.
            - final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없습니다.
        - **finally**는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록입니다.
        - **finalize**는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드입니다. GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않습니다. GC가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있습니다.
